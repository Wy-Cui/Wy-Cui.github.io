<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>vue面试题 | 崔文悦的博客</title><meta name="author" content="崔文悦"><meta name="copyright" content="崔文悦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="1.vue组件传值几种方式 父组件通过prop向子组件传值  子组件通过this.$emit()触发父组组件传递过来的方法向父组件传值  兄弟组件之间不能直接传值，需要通过父组件来做间接传值，在这种情况下推荐使用vuex  中央事件总线   1234567&#x2F;&#x2F;Bus.$emit 发送消息Bus.$emit(&#39;inceptMessage&#39;, this.msg)&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="vue面试题">
<meta property="og:url" content="https://wy-cui.github.io/2020/11/11/vue%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="崔文悦的博客">
<meta property="og:description" content="1.vue组件传值几种方式 父组件通过prop向子组件传值  子组件通过this.$emit()触发父组组件传递过来的方法向父组件传值  兄弟组件之间不能直接传值，需要通过父组件来做间接传值，在这种情况下推荐使用vuex  中央事件总线   1234567&#x2F;&#x2F;Bus.$emit 发送消息Bus.$emit(&#39;inceptMessage&#39;, this.msg)&amp;#">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-11-11T12:19:08.000Z">
<meta property="article:modified_time" content="2020-11-11T12:41:46.933Z">
<meta property="article:author" content="崔文悦">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wy-cui.github.io/2020/11/11/vue%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-11-11 20:41:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">崔文悦的博客</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">vue面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-11T12:19:08.000Z" title="发表于 2020-11-11 20:19:08">2020-11-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-11T12:41:46.933Z" title="更新于 2020-11-11 20:41:46">2020-11-11</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="1-vue组件传值几种方式"><a href="#1-vue组件传值几种方式" class="headerlink" title="1.vue组件传值几种方式"></a>1.vue组件传值几种方式</h4><ul>
<li><p>父组件通过prop向子组件传值</p>
</li>
<li><p>子组件通过this.$emit()触发父组组件传递过来的方法向父组件传值</p>
</li>
<li><p>兄弟组件之间不能直接传值，需要通过父组件来做间接传值，在这种情况下推荐使用vuex</p>
</li>
<li><p>中央事件总线  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Bus.$emit 发送消息</span><br><span class="line">Bus.$emit(&#39;inceptMessage&#39;, this.msg)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Bus.$on  接收消息</span><br><span class="line">Bus.$on(&#39;inceptMessage&#39;,(msg) &#x3D;&gt; &#123;</span><br><span class="line">	this.fromComponentAMsg &#x3D; msg</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>provide和inject</li>
</ul>
<ul>
<li><code>this.$refs</code>和<code>this.$parent</code></li>
</ul>
<p>具体例子请看<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE">官方文档</a></p>
<h4 id="2-vue-router原理"><a href="#2-vue-router原理" class="headerlink" title="2.vue-router原理"></a>2.vue-router原理</h4><p>说简单点，vue-router的原理就是监听URL地址变化，从而渲染不同的组件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vue-router的模式主要有hash模式和history模式。</span><br><span class="line"></span><br><span class="line">1.hash模式的原理(url带有#号部分)：</span><br><span class="line">	在vue-router.js的<span class="number">2.8</span>版本之前，在路由的hash部分发生了任何变化，都会执行<span class="built_in">window</span>.onhashchange方法，在这个方法内部我们可以根据当前匹配到的hash去加载对应的组件</span><br><span class="line">	在vue-router.js的<span class="number">2.8</span>版本之后，内部使用<span class="built_in">window</span>.history.pushState来完成相应的功能</span><br><span class="line">	hash模式的特点：在切换路由的时候，不会向服务器发送请求，但是刷新网页的时候，此时会向服务器发送请求，在向服务器发送请求的时候，hash部分的信息是不会发送到服务器的，所以此时刷新网页没有问题</span><br><span class="line">            </span><br><span class="line">   localhost:<span class="number">8888</span>        ---&gt;加载spa单页面应用程序</span><br><span class="line">   localhost:<span class="number">8888</span>#index  ---&gt;当localhost:<span class="number">8888</span>切换到localhost:<span class="number">8888</span>#index 没有发送请求</span><br><span class="line">   localhost:<span class="number">8888</span>#login  ---&gt;当localhost:<span class="number">8888</span>#index切换到localhost:<span class="number">8888</span>#login 没有发送请求     </span><br><span class="line">   localhost:<span class="number">8888</span>#login  ---&gt;当我们直接刷新浏览器的时候，此时会向服务器发送请求，但是我们请求url的中hash部分不会提交到服务器，所以真正的请求地址是localhost:<span class="number">8888</span>，就相当于此时重新去加载spa单页面应用程序</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>history模式的原理(url中通过/表示路径)</span><br><span class="line">	内部使用<span class="built_in">window</span>.history.pushState来处理url的变化，切换对应的组件</span><br><span class="line">	history模式的特点：在切换路由的时候，不会向服务器发送请求，但是当刷新网页的时候，此时会向服务器发送请求，如果后端没有对应的接口与此匹配，此时会报资源找不到的错误</span><br><span class="line">history模式一般情况下不能刷新网页</span><br><span class="line"></span><br><span class="line">    localhost:<span class="number">8888</span>    ---&gt;加载spa单页面应用程序</span><br><span class="line">    localhost:<span class="number">8888</span>/index ---&gt;当localhost:<span class="number">8888</span>切换到localhost:<span class="number">8888</span>/index没有发送请求</span><br><span class="line">    localhost:<span class="number">8888</span>/login ---&gt;当localhost:<span class="number">8888</span>/index切换到localhost:<span class="number">8888</span>/login没有发送请求</span><br><span class="line"></span><br><span class="line">    localhost:<span class="number">8888</span>/login  ---&gt;当我们直接刷新浏览器的时候，此时会向服务器发送请求，请求地址就是localhost:<span class="number">8888</span>/login，所以如果服务器没有对应的/login接口，那么此时会报<span class="number">404</span>错误</span><br></pre></td></tr></table></figure>

<h4 id="3-构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？"><a href="#3-构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？" class="headerlink" title="3.构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？"></a>3.构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、vue.js：vue-cli工程的核心，主要特点是双向数据绑定和组件系统。</span><br><span class="line">2、vue-router：vue官方推荐使用的路由框架。</span><br><span class="line">3、vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护vue组件间共用的一些 变量 和 方法。</span><br><span class="line">4、axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。</span><br><span class="line">5、vux  mint-UI  AntDesign  ElementUI vant等：为vue设计的UI组件库。</span><br><span class="line">6、创建一个emit.js文件，用于vue事件机制的管理。</span><br><span class="line">7、webpack：模块加载和vue-cli工程打包器。</span><br><span class="line">8、AnimateCSS：动画库</span><br></pre></td></tr></table></figure>

<h4 id="4-vue-cli-工程常用的-npm-命令有哪些？"><a href="#4-vue-cli-工程常用的-npm-命令有哪些？" class="headerlink" title="4.vue-cli 工程常用的 npm 命令有哪些？"></a>4.vue-cli 工程常用的 npm 命令有哪些？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run serve             启动vue-cli开发环境的npm命令</span><br><span class="line">npm run build             vue-cli生成生产环境部署资源的npm命令；</span><br><span class="line">npm run build --report    用于查看vue-cli生产环境部署资源文件大小</span><br></pre></td></tr></table></figure>

<h4 id="5-请说出vue-cli工程中每个文件夹和文件的用处"><a href="#5-请说出vue-cli工程中每个文件夹和文件的用处" class="headerlink" title="5.请说出vue-cli工程中每个文件夹和文件的用处"></a>5.请说出vue-cli工程中每个文件夹和文件的用处</h4><p><img src="/2020/11/11/vue%E9%9D%A2%E8%AF%95%E9%A2%98/1576547771792.png" alt="1576547771792"></p>
<h4 id="6-vue-config-js-的对于工程-开发环境-和-生产环境-的配置"><a href="#6-vue-config-js-的对于工程-开发环境-和-生产环境-的配置" class="headerlink" title="6.vue.config.js 的对于工程 开发环境 和 生产环境 的配置"></a>6.vue.config.js 的对于工程 开发环境 和 生产环境 的配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">configureWebpack: config &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 开发环境配置</span><br><span class="line">  if (debug) &#123;  </span><br><span class="line">    &#x2F;&#x2F; cheap-module-eval-source-map是打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射</span><br><span class="line">    config.devtool &#x3D; &#39;#cheap-module-eval-source-map&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 生产环境配置</span><br><span class="line">  else &#123; </span><br><span class="line">     &#x2F;&#x2F;生成一个没有列信息（column-mappings）的SourceMaps文件，同时 loader 的 sourcemap 也被简化为只包含对应行的</span><br><span class="line">     config.devtool &#x3D; &#39;cheap-module-source-map&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 开发生产共同配置</span><br><span class="line">  Object.assign(config, &#123; </span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        &#39;@&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#39;),</span><br><span class="line">        &#39;vue$&#39;: &#39;vue&#x2F;dist&#x2F;vue.esm.js&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="7-请你详细介绍一些-package-json-里面的配置"><a href="#7-请你详细介绍一些-package-json-里面的配置" class="headerlink" title="7.请你详细介绍一些 package.json 里面的配置"></a>7.请你详细介绍一些 package.json 里面的配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;cli-study&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;vue-cli-service lint&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;vue&quot;: &quot;^2.5.21&quot;,</span><br><span class="line">    &quot;vue-router&quot;: &quot;^3.0.1&quot;,</span><br><span class="line">    &quot;vuex&quot;: &quot;^3.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@vue&#x2F;cli-plugin-babel&quot;: &quot;^3.3.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;cli-plugin-eslint&quot;: &quot;^3.3.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;cli-service&quot;: &quot;^3.3.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;eslint-config-prettier&quot;: &quot;^4.0.1&quot;,</span><br><span class="line">    &quot;babel-eslint&quot;: &quot;^10.0.1&quot;,</span><br><span class="line">    &quot;eslint&quot;: &quot;^5.8.0&quot;,</span><br><span class="line">    &quot;eslint-plugin-vue&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;less&quot;: &quot;^3.0.4&quot;,</span><br><span class="line">    &quot;less-loader&quot;: &quot;^4.1.0&quot;,</span><br><span class="line">    &quot;lint-staged&quot;: &quot;^8.1.0&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.5.21&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;gitHooks&quot;: &#123;</span><br><span class="line">    &quot;pre-commit&quot;: &quot;lint-staged&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;lint-staged&quot;: &#123;</span><br><span class="line">    &quot;*.js&quot;: [</span><br><span class="line">      &quot;vue-cli-service lint&quot;,</span><br><span class="line">      &quot;git add&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;*.vue&quot;: [</span><br><span class="line">      &quot;vue-cli-service lint&quot;,</span><br><span class="line">      &quot;git add&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用对象解析：</p>
<ul>
<li>scripts：npm run xxx 命令调用node执行的 .js 文件</li>
<li>dependencies：生产环境依赖包的名称和版本号，即这些 依赖包 都会打包进 生产环境的JS文件里面</li>
<li>devDependencies：开发环境依赖包的名称和版本号，即这些 依赖包 只用于 代码开发 的时候，不会打包进 生产环境js文件 里面</li>
</ul>
<h4 id="8-vue-js的核心"><a href="#8-vue-js的核心" class="headerlink" title="8.vue.js的核心"></a>8.vue.js的核心</h4><p>1、数据驱动，也叫双向数据绑定。</p>
<blockquote>
<p>Vue.js使用ES5的Object.defineProperty和存储器属性: getter和setter实现数据的监听(兼容IE9及以上版本)。核心是VM，即ViewModel，保证数据和视图的一致性。</p>
</blockquote>
<p>2、组件系统。</p>
<p>.vue组件的核心选项:</p>
<blockquote>
<p>1、模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系。<br>2、初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。<br>3、接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。<br>4、方法（methods）：对数据的改动操作一般都在组件的方法内进行。<br>5、生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，最新2.0版本对于生命周期函数名称改动很大。<br>6、私有资源（directives、components、filters）：Vue.js当中将用户自定义的指令、过滤器、组件等统称为资源。一个组件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用。</p>
</blockquote>
<p>3、vuex。</p>
<blockquote>
<p>vuex是是vue中的状态管理方案，主要用于多个组件之间的数据共享。</p>
</blockquote>
<h4 id="9-对于-Vue-是一套-构建用户界面-的-渐进式框架-的理解"><a href="#9-对于-Vue-是一套-构建用户界面-的-渐进式框架-的理解" class="headerlink" title="9.对于 Vue 是一套 构建用户界面 的 渐进式框架 的理解"></a>9.对于 Vue 是一套 构建用户界面 的 渐进式框架 的理解</h4><p>渐进式代表的含义是：没有多做职责之外的事。vue.js只提供了 vue-cli 生态中最核心的 <code>组件系统</code> 和 <code>双向数据绑定</code>。像<code>vuex</code>、<code>vue-router</code>都属于围绕 <code>vue.js</code>开发的库，可以集成也可以不集成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">比如说，你要使用Angular，必须接受以下东西：</span><br><span class="line">- 必须使用它的模块机制</span><br><span class="line">- 必须使用它的依赖注入</span><br><span class="line">- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）</span><br><span class="line">所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">比如说，你要使用React，你必须理解：</span><br><span class="line">- 函数式编程的理念</span><br><span class="line">- 需要知道什么是副作用</span><br><span class="line">- 什么是纯函数</span><br><span class="line">- 如何隔离副作用</span><br><span class="line">- 它的侵入性看似没有Angular那么强，主要因为它是软性侵入。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue与React、Angular的不同是，但它是渐进的：</span><br><span class="line">- 你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用</span><br><span class="line">- 也可以整个用它全家桶开发，当Angular用；</span><br><span class="line">- 还可以只用它的视图，搭配你自己设计的整个下层应用。</span><br><span class="line">- 你可以在底层数据逻辑的地方用oop(对象编程)，也可以函数式编程，都可以，它只是个轻量视图而已，只做了最核心的东西。</span><br></pre></td></tr></table></figure>

<h4 id="10-请说出vue几种常用的指令"><a href="#10-请说出vue几种常用的指令" class="headerlink" title="10.请说出vue几种常用的指令"></a>10.请说出vue几种常用的指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- v-if：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 &#x2F; 组件被销毁并重建。</span><br><span class="line">- v-show：根据表达式之真假值，切换元素的 display CSS 属性。</span><br><span class="line">- v-for：循环指令，基于一个数组或者对象渲染一个列表，vue 2.0以上必须需配合 key值 使用。</span><br><span class="line">- v-bind：动态地绑定一个或多个特性，或一个组件 prop 到表达式。</span><br><span class="line">- v-on：用于监听指定元素的DOM事件，比如点击事件。绑定事件监听器。</span><br><span class="line">- v-model：实现表单输入和应用状态之间的双向绑定</span><br><span class="line">- v-pre：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</span><br><span class="line">- v-once：只渲染元素和组件一次。随后的重新渲染，元素&#x2F;组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</span><br><span class="line">- v-html: 显示html</span><br></pre></td></tr></table></figure>

<h4 id="11-请问-v-if-和-v-show-有什么区别"><a href="#11-请问-v-if-和-v-show-有什么区别" class="headerlink" title="11.请问 v-if 和 v-show 有什么区别"></a>11.请问 v-if 和 v-show 有什么区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">共同点：</span><br><span class="line">v-if 和 v-show 都是动态显示DOM元素。</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">1、编译过程： v-if是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-show的元素始终会被渲染并保留在DOM中。v-show 只是简单地切换元素的CSS属性display。</span><br><span class="line">2、编译条件： v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做。直到条件第一次变为真时，才会开始渲染条件块。v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</span><br><span class="line">3、性能消耗： v-if有更高的切换消耗。v-show有更高的初始渲染消耗。</span><br><span class="line">4、应用场景： v-if适合运行时条件很少改变时使用。v-show适合频繁切换。</span><br></pre></td></tr></table></figure>

<h4 id="12-vue常用的修饰符"><a href="#12-vue常用的修饰符" class="headerlink" title="12.vue常用的修饰符"></a>12.vue常用的修饰符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">v-on 指令常用修饰符：</span><br><span class="line"></span><br><span class="line">- .stop - 调用 event.stopPropagation()，禁止事件冒泡。</span><br><span class="line">- .prevent - 调用 event.preventDefault()，阻止事件默认行为。</span><br><span class="line">- .capture - 添加事件侦听器时使用 capture 模式。</span><br><span class="line">- .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</span><br><span class="line">- .&#123;keyCode | keyAlias&#125; - 只当事件是从特定键触发时才触发回调。</span><br><span class="line">- .native - 监听组件根元素的原生事件。</span><br><span class="line">- .once - 只触发一次回调。</span><br><span class="line">- .left - (<span class="number">2.2</span><span class="number">.0</span>) 只当点击鼠标左键时触发。</span><br><span class="line">- .right - (<span class="number">2.2</span><span class="number">.0</span>) 只当点击鼠标右键时触发。</span><br><span class="line">- .middle - (<span class="number">2.2</span><span class="number">.0</span>) 只当点击鼠标中键时触发。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意： 如果是在自己封装的组件或者是使用一些第三方的UI库时，会发现一些事件并不起效果，这时就需要用.native修饰符了，如当我们使用element-ui中的el-input组件时的@keyup.enter事件：</span></span><br><span class="line">&lt;el-input</span><br><span class="line">  v-model=<span class="string">&quot;inputName&quot;</span></span><br><span class="line">  placeholder=<span class="string">&quot;搜索你的文件&quot;</span></span><br><span class="line">  @keyup.enter.native=<span class="string">&quot;searchFile(params)&quot;</span></span><br><span class="line">  &gt;</span><br><span class="line">&lt;/el-input&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v-bind 指令常用修饰符：</span><br><span class="line">- .prop   被用于绑定 DOM 属性 (property)。(差别在哪里？)</span><br><span class="line">- .camel  (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)</span><br><span class="line">- .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。</span><br><span class="line"></span><br><span class="line">v-model 指令常用修饰符：</span><br><span class="line">- .lazy    取代 input 监听 change 事件</span><br><span class="line">- .number  输入字符串转为数字</span><br><span class="line">- .trim    输入首尾空格过滤</span><br></pre></td></tr></table></figure>

<h4 id="13-v-on可以监听多个方法吗？"><a href="#13-v-on可以监听多个方法吗？" class="headerlink" title="13.v-on可以监听多个方法吗？"></a>13.v-on可以监听多个方法吗？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v-on可以监听多个方法，例如：</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;name&quot; @input&#x3D;&quot;onInput&quot; @focus&#x3D;&quot;onFocus&quot; @blur&#x3D;&quot;onBlur&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">也可以给一个事件绑定多个方法，如以下代码：</span><br><span class="line">&lt;p @click&#x3D;&quot;one(),two()&quot;&gt;点击&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="14-vue中-key-值的作用"><a href="#14-vue中-key-值的作用" class="headerlink" title="14.vue中 key 值的作用"></a>14.vue中 key 值的作用</h4><p>key值：用于管理可复用的元素。因为<code>Vue</code> 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做使 Vue 变得非常快，但是这样也不总是符合实际需求。</p>
<blockquote>
<p>2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的，key的取值需要是number或者string，而且需要在同级唯一。</p>
</blockquote>
<h4 id="15-vue事件中如何使用event对象"><a href="#15-vue事件中如何使用event对象" class="headerlink" title="15.vue事件中如何使用event对象"></a>15.vue事件中如何使用event对象</h4><p>注意在事件中要使用 $ 符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;html部分</span><br><span class="line">&lt;a href&#x3D;&quot;javascript:void(0);&quot; data-id&#x3D;&quot;12&quot; @click&#x3D;&quot;showEvent($event)&quot;&gt;event&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;js部分</span><br><span class="line">showEvent(event)&#123;</span><br><span class="line">    &#x2F;&#x2F;获取自定义data-id</span><br><span class="line">	console.log(event.target.dataset.id)</span><br><span class="line">   &#x2F;&#x2F;阻止事件冒泡</span><br><span class="line">    event.stopPropagation(); </span><br><span class="line">    &#x2F;&#x2F;阻止默认</span><br><span class="line">    event.preventDefault()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-什么是-nextTick"><a href="#16-什么是-nextTick" class="headerlink" title="16.什么是$nextTick"></a>16.什么是$nextTick</h4><p><code>$nextTick</code> 下一次dom更新完毕之后执行</p>
<p>因为<code>Vue</code>的异步更新队列，<code>$nextTick</code>是用来知道什么时候<code>DOM</code>更新完成的。</p>
<h4 id="17-Vue-组件中-data-为什么必须是函数"><a href="#17-Vue-组件中-data-为什么必须是函数" class="headerlink" title="17.Vue 组件中 data 为什么必须是函数"></a>17.Vue 组件中 data 为什么必须是函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;为什么data函数里面要return一个对象</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;  &#x2F;&#x2F; 返回一个唯一的对象，不要和其他组件共用一个对象进行返回</span><br><span class="line">                menu: MENU.data,</span><br><span class="line">                poi: POILIST.data</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>因为一个组件是可以共享的，同一个组件类可以创建很多个组件对象，但每一个组件对象的data应该是私有的，所以每个组件都要return一个新的data对象，返回一个唯一的对象，不要和其他组件共用一个对象。</p>
<h4 id="18-v-for-与-v-if-的优先级"><a href="#18-v-for-与-v-if-的优先级" class="headerlink" title="18.v-for 与 v-if 的优先级"></a>18.v-for 与 v-if 的优先级</h4><p>当它们处于同一节点，<code>v-for</code>的优先级比<code>v-if</code>更高，这意味着 <code>v-if</code>将分别重复运行于每个 <code>v-for</code>循环中。</p>
<h4 id="19-vue中子组件调用父组件的方法"><a href="#19-vue中子组件调用父组件的方法" class="headerlink" title="19.vue中子组件调用父组件的方法"></a>19.vue中子组件调用父组件的方法</h4><p>主要步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、在父组件创建子组件实例的时候，通过v-on给子组件传递一个自定义事件。</span><br><span class="line">2、在子组件中通过&#39;$emit&#39;触发当前实例上的自定义事件。</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<p>父组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;fatherPageWrap&quot;&gt;</span><br><span class="line">          &lt;h1&gt;这是父组件&lt;&#x2F;h1&gt;</span><br><span class="line">          &lt;!-- 引入子组件，v-on监听自定义事件 --&gt;</span><br><span class="line">          &lt;emitChild v-on:emitMethods&#x3D;&quot;fatherMethod&quot;&gt;&lt;&#x2F;emitChild&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    import emitChild from &#39;@&#x2F;page&#x2F;children&#x2F;emitChild.vue&#39;;</span><br><span class="line">	export default&#123;</span><br><span class="line">		data () &#123;</span><br><span class="line">		    return &#123;&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		components : &#123;</span><br><span class="line">            emitChild</span><br><span class="line">		&#125;,</span><br><span class="line">		methods : &#123;</span><br><span class="line">		    fatherMethod(params)&#123;</span><br><span class="line">                 alert(JSON.stringify(params));</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;childPageWrap&quot;&gt;</span><br><span class="line">         &lt;h1&gt;这是子组件&lt;&#x2F;h1&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">	export default&#123;</span><br><span class="line">		data () &#123;</span><br><span class="line">		   return &#123;&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		mounted () &#123;</span><br><span class="line">           &#x2F;&#x2F;通过 emit 触发</span><br><span class="line">           this.$emit(&#39;emitMethods&#39;,&#123;&quot;name&quot; : 123&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>结果：子组件 会调用 父组件的<code>fatherMethod</code> 方法，该并且会<code>alert</code> 传递过去的参数：<code>&#123;&quot;name&quot;:123&#125;</code></p>
<h4 id="20-vue中-keep-alive-组件的作用"><a href="#20-vue中-keep-alive-组件的作用" class="headerlink" title="20.vue中 keep-alive 组件的作用"></a>20.vue中 keep-alive 组件的作用</h4><p><code>keep-alive：</code>主要用于<code>保留组件状态</code>或<code>避免组件重新渲染</code>。</p>
<p><strong>属性：</strong></p>
<ul>
<li><code>include:</code>字符串或正则表达式。只有匹配的组件会被缓存。</li>
<li><code>exclude：</code>字符串或正则表达式。任何匹配的组件都不会被缓存。</li>
</ul>
<h4 id="21-vue中如何编写可复用的组件"><a href="#21-vue中如何编写可复用的组件" class="headerlink" title="21.vue中如何编写可复用的组件"></a>21.vue中如何编写可复用的组件</h4><p>组件由状态、事件和嵌套的片断组成。</p>
<p>状态 props，是组件当前的某些数据或属性，如 video 中的 src、width 和 height。</p>
<p>事件 events，是组件在特定时机触发一些操作的行为，如 video 在视频资源加载成功或失败时会触发对应的事件来执行处理。</p>
<p>片段 slots，指的是嵌套在组件标签中的内容，该内容会在某些条件下展现出来，如在浏览器不支持 video 标签时显示提示信息。</p>
<p>在编写组件的时候，要时刻考虑组件的复用性，良好的可复用组件应当定义一个清晰的公开接口。</p>
<ul>
<li><strong>props</strong> 允许外部环境传递数据给组件</li>
<li><strong>events</strong> 允许组件触发外部环境的副作用</li>
<li><strong>slots</strong> 允许外部环境将额外的内容组合在组件中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-video</span><br><span class="line">  :playlist&#x3D;&quot;playlist&quot;</span><br><span class="line">  width&#x3D;&quot;320&quot;</span><br><span class="line">  height&#x3D;&quot;240&quot;</span><br><span class="line">  @load&#x3D;&quot;loadHandler&quot;</span><br><span class="line">  @error&#x3D;&quot;errorHandler&quot;</span><br><span class="line">  @playnext&#x3D;&quot;nextHandler&quot;</span><br><span class="line">  @playprev&#x3D;&quot;prevHandler&quot;&gt;</span><br><span class="line">  &lt;div slot&#x3D;&quot;endpage&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;my-video&gt;</span><br></pre></td></tr></table></figure>

<h4 id="22-什么是vue生命周期和生命周期钩子函数"><a href="#22-什么是vue生命周期和生命周期钩子函数" class="headerlink" title="22.什么是vue生命周期和生命周期钩子函数"></a>22.什么是vue生命周期和生命周期钩子函数</h4><p><code>vue 的生命周期是：</code> vue 实例从创建到销毁，也就是从<code>开始创建</code>、<code>初始化数据</code>、<code>编译模板</code>、<code>挂载Dom→渲染</code>、<code>更新→渲染</code>、<code>卸载</code>等一系列过程。</p>
<p>在这个过程中也会<code>运行</code>一些叫做<code>生命周期钩子的函数</code>，这给了<code>用户</code>在不同阶段<code>添加自己的代码</code>的机会。</p>
<h4 id="23-vue生命周期钩子函数有哪些"><a href="#23-vue生命周期钩子函数有哪些" class="headerlink" title="23.vue生命周期钩子函数有哪些"></a>23.vue生命周期钩子函数有哪些</h4><table>
<thead>
<tr>
<th>生命周期钩子函数（11个）</th>
<th>类型</th>
<th>详细</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>Function</td>
<td>在<code>实例初始化之后</code>，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</td>
</tr>
<tr>
<td>created</td>
<td>Function</td>
<td>在<code>实例创建完成后</code>被立即调用。在这一步，实例已完成以下的配置：<code>数据观测 (data observer)</code>， <code>属性和方法的运算</code>，<code>watch/event 事件回调</code>。然而，挂载阶段还没开始，$el 属性目前不可见。</td>
</tr>
<tr>
<td>beforeMount</td>
<td>Function</td>
<td>在<code>挂载开始之前</code>被调用：相关的 render 函数首次被调用。</td>
</tr>
<tr>
<td>mounted</td>
<td>Function</td>
<td><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并<code>挂载到实例上去之后</code>调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>Function</td>
<td><code>数据更新时调用</code>，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。<strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></td>
</tr>
<tr>
<td>updated</td>
<td>Function</td>
<td>由于数据更改导致的<code>虚拟 DOM 重新渲染和打补丁</code>，在这<code>之后</code>会<code>调用</code>该钩子。</td>
</tr>
<tr>
<td>activated</td>
<td>Function</td>
<td><code>keep-alive 组件激活时调用</code>。<strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td>deactivated</td>
<td>Function</td>
<td><code>keep-alive 组件停用时调用</code>。<strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>Function</td>
<td>实例销毁之前调用。在这一步，实例仍然完全可用。<strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td>destroyed</td>
<td>Function</td>
<td>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td>errorCaptured（2.5.0+ 新增）</td>
<td>(err: Error, vm: Component, info: string) =&gt; ?boolean</td>
<td>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、mounted、updated不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用vm.$nextTick替换掉mounted、updated：</span><br><span class="line"></span><br><span class="line">updated: function () &#123;</span><br><span class="line">    this.$nextTick(function () &#123;</span><br><span class="line">        &#x2F;&#x2F; Code that will run only after the</span><br><span class="line">        &#x2F;&#x2F; entire view has been re-rendered</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、http请求建议在 created 生命周期内发出</span><br></pre></td></tr></table></figure>

<p><strong>vue生命周期图示：</strong><br><img src="/2020/11/11/vue%E9%9D%A2%E8%AF%95%E9%A2%98/lifecycle.png" alt="img"></p>
<h4 id="24-vue如何监听键盘事件中的按键"><a href="#24-vue如何监听键盘事件中的按键" class="headerlink" title="24.vue如何监听键盘事件中的按键"></a>24.vue如何监听键盘事件中的按键</h4><p>我们可以通过按键修饰符来监听键盘事件中的按键 。<code>Vue</code>允许为 <code>v-on</code>在监听键盘事件时添加<code>按键修饰符</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-on:keyup.enter&#x3D;&quot;submit&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写语法 --&gt;</span><br><span class="line">&lt;input @keyup.enter&#x3D;&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>全部的按键别名：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- .enter</span><br><span class="line">- .tab</span><br><span class="line">- .delete (捕获“删除”和“退格”键)</span><br><span class="line">- .esc</span><br><span class="line">- .space</span><br><span class="line">- .up</span><br><span class="line">- .down</span><br><span class="line">- .left</span><br><span class="line">- .right</span><br></pre></td></tr></table></figure>

<p>可以通过全局 <code>config.keyCodes</code> 对象<code>自定义按键修饰符别名</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以使用 &#96;v-on:keyup.f1&#96;</span><br><span class="line">Vue.config.keyCodes.f1 &#x3D; 112</span><br></pre></td></tr></table></figure>

<p><strong>系统修饰键：</strong></p>
<blockquote>
<p>2.1.0 新增</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</span><br><span class="line">- .ctrl</span><br><span class="line">- .alt</span><br><span class="line">- .shift</span><br><span class="line">- .meta</span><br><span class="line"></span><br><span class="line">&lt;!-- Alt + C --&gt;</span><br><span class="line">&lt;input @keyup.alt.67&#x3D;&quot;clear&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Ctrl + Click --&gt;</span><br><span class="line">&lt;div @click.ctrl&#x3D;&quot;doSomething&quot;&gt;Do something&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.5.0 新增</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.exact修饰符允许你控制由精确的系统修饰符组合触发的事件。</span><br><span class="line"></span><br><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl.exact&#x3D;&quot;onCtrlClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button @click.exact&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p><strong>鼠标按钮修饰符：</strong></p>
<blockquote>
<p>2.2.0 新增</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- .left</span><br><span class="line">- .right</span><br><span class="line">- .middle</span><br><span class="line"></span><br><span class="line">这些修饰符会限制处理函数仅响应特定的鼠标按钮。</span><br></pre></td></tr></table></figure>

<h4 id="25-vue更新数组时触发视图更新的方法"><a href="#25-vue更新数组时触发视图更新的方法" class="headerlink" title="25.vue更新数组时触发视图更新的方法"></a>25.vue更新数组时触发视图更新的方法</h4><p>Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- push()  &#x2F;&#x2F;push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</span><br><span class="line">- pop()   &#x2F;&#x2F;pop() 方法用于删除最后一个元素，把数组长度减 1，并且返回它删除的元素的值。</span><br><span class="line">- shift()           &#x2F;&#x2F;shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。</span><br><span class="line">- unshift()         &#x2F;&#x2F;unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</span><br><span class="line">- splice()	        &#x2F;&#x2F;splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目。 该方法会改变原始数组。</span><br><span class="line">- sort()			&#x2F;&#x2F;sort() 方法用于对数组的元素进行排序。</span><br><span class="line">- reverse()         &#x2F;&#x2F;reverse() 方法用于颠倒数组中元素的顺序。</span><br><span class="line"></span><br><span class="line">当我们调用数组的上面这些方法修改数组的时候，页面会更新</span><br></pre></td></tr></table></figure>

<h4 id="26-vue中对象更改检测的注意事项"><a href="#26-vue中对象更改检测的注意事项" class="headerlink" title="26.vue中对象更改检测的注意事项"></a>26.vue中对象更改检测的注意事项</h4><pre><code>由于JavaScript的限制，Vue不能检测对象属性的添加或删除：</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; &#96;vm.a&#96;  响应式属性</span><br><span class="line"></span><br><span class="line">vm.b &#x3D; 2</span><br><span class="line">&#x2F;&#x2F; &#96;vm.b&#96;  非响应式属性</span><br></pre></td></tr></table></figure>

<pre><code>对于已经创建的实例，Vue不能动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, key, value)`方法向嵌套对象`添加响应式属性`。例如，对于：</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userProfile: &#123;</span><br><span class="line">      name: &#39;Anika&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你可以添加一个新的 age 属性到嵌套的 userProfile对象：</span><br><span class="line">Vue.set(vm.userProfile, &#39;age&#39;, 27)</span><br><span class="line"></span><br><span class="line">你还可以使用 vm.$set实例方法，它只是全局Vue.set 的别名：</span><br><span class="line">vm.$set(vm.userProfile, &#39;age&#39;, 27)</span><br></pre></td></tr></table></figure>

<pre><code>有时你可能需要为已有对象赋予多个新属性，比如使用 `Object.assign()`或 `_.extend()`。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想`添加新的响应式属性`，不要像这样：</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(vm.userProfile, &#123;</span><br><span class="line">  age: 27,</span><br><span class="line">  favoriteColor: &#39;Vue Green&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<pre><code>应该这样做：</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.userProfile &#x3D; Object.assign(&#123;&#125;, vm.userProfile, &#123;</span><br><span class="line">  age: 27,</span><br><span class="line">  favoriteColor: &#39;Vue Green&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="27-如何解决非工程化项目，网速慢时初始化页面闪动问题？"><a href="#27-如何解决非工程化项目，网速慢时初始化页面闪动问题？" class="headerlink" title="27.如何解决非工程化项目，网速慢时初始化页面闪动问题？"></a>27.如何解决非工程化项目，网速慢时初始化页面闪动问题？</h4><pre><code>使用`v-cloak`指令，`v-cloak`不需要表达式，它会在`Vue`实例结束编译时从绑定的HTML元素上移除，经常和CSS的`display:none`配合使用。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot; v-cloak&gt;</span><br><span class="line">	&#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message:&quot;这是一段文本&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[v-cloak]&#123;</span><br><span class="line">    display:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>在一般情况下，`v-cloak`是一个解决初始化慢导致页面闪动的最佳实践，对于简单的项目很实用。</code></pre>
<h4 id="28-v-for产生的列表，如何实现active样式的切换？"><a href="#28-v-for产生的列表，如何实现active样式的切换？" class="headerlink" title="28.v-for产生的列表，如何实现active样式的切换？"></a>28.v-for产生的列表，如何实现active样式的切换？</h4><p>通过设置当前 currentIndex 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;toggleClassWrap&quot;&gt;</span><br><span class="line">	 &lt;ul&gt;</span><br><span class="line">	    &lt;!--li是否有clicked样式取决于当前的currentIndex等于多少--&gt;</span><br><span class="line">		&lt;li @click&#x3D;&quot;currentIndex &#x3D; index&quot; v-bind:class&#x3D;&quot;&#123;clicked: index &#x3D;&#x3D;&#x3D; currentIndex&#125;&quot; v-for&#x3D;&quot;(item, index) in desc&quot; :key&#x3D;&quot;index&quot;&gt;</span><br><span class="line">			&lt;a href&#x3D;&quot;javascript:;&quot;&gt;&#123;&#123;item.ctrlValue&#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">		&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;&#x2F;ul&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">	export default&#123;</span><br><span class="line">		data () &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				desc:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        ctrlValue:&quot;test1&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        ctrlValue:&quot;test2&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        ctrlValue:&quot;test3&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        ctrlValue:&quot;test4&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">				],</span><br><span class="line">				currentIndex:0</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot; lang&#x3D;&quot;less&quot;&gt;</span><br><span class="line">.toggleClassWrap&#123;</span><br><span class="line">	.clicked&#123;</span><br><span class="line">		color:red;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h4 id="29-vue-cli工作中如何自定义一个过滤器？"><a href="#29-vue-cli工作中如何自定义一个过滤器？" class="headerlink" title="29.vue-cli工作中如何自定义一个过滤器？"></a>29.vue-cli工作中如何自定义一个过滤器？</h4><p>1.可以在组件内部定义私有过滤器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">      el: &#39;#app&#39;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: &#39;曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;&#125;,</span><br><span class="line">	  filters: &#123; </span><br><span class="line">        &#x2F;&#x2F; 过滤器的三个参数：1.要过滤的文本   2.过滤的内容   3.替换的内容</span><br><span class="line">        &#x2F;&#x2F; 过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称一致了，这时候优先调用私有过滤器</span><br><span class="line">        msgFormat: function (msg, arg, arg2) &#123;</span><br><span class="line">           &#x2F;&#x2F; 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则</span><br><span class="line">		   return msg.replace(&#x2F;少年&#x2F;g, arg + arg2)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>2.可以使用Vue.filter定义全局过滤器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个 Vue 全局的过滤器，名字叫做  msgFormat</span><br><span class="line">   Vue.filter(&#39;msgFormat&#39;, function (msg, arg, arg2) &#123;</span><br><span class="line">     &#x2F;&#x2F; 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则</span><br><span class="line">     return msg.replace(&#x2F;单纯&#x2F;g, arg + arg2)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<p>3.在页面中使用管道修饰符来用过滤器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; msg | msgFormat(&#39;疯狂+1&#39;, &#39;123&#39;) | test &#125;&#125;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="30-vue-cli工作中常用的过滤器"><a href="#30-vue-cli工作中常用的过滤器" class="headerlink" title="30.vue-cli工作中常用的过滤器"></a>30.vue-cli工作中常用的过滤器</h4><p>创建一个filter.js，用来存放各种过滤器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.去除空格  type 1-所有空格  2-前后空格  3-前空格 4-后空格</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">value, trim</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (trim) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> value.replace(<span class="regexp">/\s+/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> value.replace(<span class="regexp">/(^\s*)|(\s*$)/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> value.replace(<span class="regexp">/(^\s*)/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> value.replace(<span class="regexp">/(\s*$)/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.任意格式日期处理</span></span><br><span class="line"><span class="comment">//使用格式：</span></span><br><span class="line"><span class="comment">// &#123;&#123; &#x27;2018-09-14 01:05&#x27; | formaDate(yyyy-MM-dd hh:mm:ss) &#125;&#125; </span></span><br><span class="line"><span class="comment">// &#123;&#123; &#x27;2018-09-14 01:05&#x27; | formaDate(yyyy-MM-dd) &#125;&#125; </span></span><br><span class="line"><span class="comment">// &#123;&#123; &#x27;2018-09-14 01:05&#x27; | formaDate(MM/dd) &#125;&#125; 等</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formaDate</span>(<span class="params">value, fmt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line">    <span class="keyword">var</span> o = &#123;</span><br><span class="line">      <span class="string">&quot;M+&quot;</span>: date.getMonth() + <span class="number">1</span>, <span class="comment">//月份</span></span><br><span class="line">      <span class="string">&quot;d+&quot;</span>: date.getDate(), <span class="comment">//日</span></span><br><span class="line">      <span class="string">&quot;h+&quot;</span>: date.getHours(), <span class="comment">//小时</span></span><br><span class="line">      <span class="string">&quot;m+&quot;</span>: date.getMinutes(), <span class="comment">//分</span></span><br><span class="line">      <span class="string">&quot;s+&quot;</span>: date.getSeconds(), <span class="comment">//秒</span></span><br><span class="line">      <span class="string">&quot;w+&quot;</span>: date.getDay(), <span class="comment">//星期</span></span><br><span class="line">      <span class="string">&quot;q+&quot;</span>: <span class="built_in">Math</span>.floor((date.getMonth() + <span class="number">3</span>) / <span class="number">3</span>), <span class="comment">//季度</span></span><br><span class="line">      <span class="string">&quot;S&quot;</span>: date.getMilliseconds() <span class="comment">//毫秒</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/(y+)/</span>.test(fmt)) fmt = fmt.replace(<span class="built_in">RegExp</span>.$1, (date.getFullYear() + <span class="string">&quot;&quot;</span>).substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$1.length));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> o) &#123;</span><br><span class="line">      <span class="function"><span class="title">if</span>(<span class="params">k === <span class="string">&#x27;w+&#x27;</span></span>)</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">o[k] === <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">          fmt = fmt.replace(<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;周日&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">o[k] === <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">          fmt = fmt.replace(<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;周一&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">o[k] === <span class="number">2</span></span>)</span> &#123;</span><br><span class="line">          fmt = fmt.replace(<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;周二&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">o[k] === <span class="number">3</span></span>)</span> &#123;</span><br><span class="line">          fmt = fmt.replace(<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;周三&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">o[k] === <span class="number">4</span></span>)</span> &#123;</span><br><span class="line">          fmt = fmt.replace(<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;周四&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">o[k] === <span class="number">5</span></span>)</span> &#123;</span><br><span class="line">          fmt = fmt.replace(<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;周五&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">o[k] === <span class="number">6</span></span>)</span> &#123;</span><br><span class="line">          fmt = fmt.replace(<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;周六&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;(&quot;</span> + k + <span class="string">&quot;)&quot;</span>).test(fmt)) &#123;</span><br><span class="line">        fmt = fmt.replace(<span class="built_in">RegExp</span>.$1, (<span class="built_in">RegExp</span>.$1.length == <span class="number">1</span>) ? (o[k]) : ((<span class="string">&quot;00&quot;</span> + o[k]).substr((<span class="string">&quot;&quot;</span> + o[k]).length)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//3.字母大小写切换</span></span><br><span class="line"><span class="comment">/*type</span></span><br><span class="line"><span class="comment"> 1:首字母大写</span></span><br><span class="line"><span class="comment"> 2：首页母小写</span></span><br><span class="line"><span class="comment"> 3：大小写转换</span></span><br><span class="line"><span class="comment"> 4：全部大写</span></span><br><span class="line"><span class="comment"> 5：全部小写</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeCase</span>(<span class="params">str, type</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ToggleCase</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> itemText = <span class="string">&quot;&quot;</span></span><br><span class="line">        str.split(<span class="string">&quot;&quot;</span>).forEach(</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="regexp">/^([a-z]+)/</span>.test(item)) &#123;</span><br><span class="line">                    itemText += item.toUpperCase();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/^([A-Z]+)/</span>.test(item)) &#123;</span><br><span class="line">                    itemText += item.toLowerCase();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    itemText += item;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">return</span> itemText;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> str.replace(<span class="regexp">/\b\w+\b/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> word.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + word.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> str.replace(<span class="regexp">/\b\w+\b/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> word.substring(<span class="number">0</span>, <span class="number">1</span>).toLowerCase() + word.substring(<span class="number">1</span>).toUpperCase();</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> ToggleCase(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> str.toLowerCase();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.字符串循环复制,count-&gt;次数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatStr</span>(<span class="params">str, count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        text += str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.字符串替换</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceAll</span>(<span class="params">str, AFindText, ARepText</span>) </span>&#123;</span><br><span class="line">    raRegExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(AFindText, <span class="string">&quot;g&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> str.replace(raRegExp, ARepText);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符替换*，隐藏手机号或者身份证号等</span></span><br><span class="line"><span class="comment">//replaceStr(字符串,字符格式, 替换方式,替换的字符（默认*）)</span></span><br><span class="line"><span class="comment">//ecDo.replaceStr(&#x27;18819322663&#x27;,[3,5,3],0)</span></span><br><span class="line"><span class="comment">//result：188*****663</span></span><br><span class="line"><span class="comment">//ecDo.replaceStr(&#x27;asdasdasdaa&#x27;,[3,5,3],1)</span></span><br><span class="line"><span class="comment">//result：***asdas***</span></span><br><span class="line"><span class="comment">//ecDo.replaceStr(&#x27;1asd88465asdwqe3&#x27;,[5],0)</span></span><br><span class="line"><span class="comment">//result：*****8465asdwqe3</span></span><br><span class="line"><span class="comment">//ecDo.replaceStr(&#x27;1asd88465asdwqe3&#x27;,[5],1,&#x27;+&#x27;)</span></span><br><span class="line"><span class="comment">//result：&quot;1asd88465as+++++&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceStr</span>(<span class="params">str, regArr, type, ARepText</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> regtext = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        Reg = <span class="literal">null</span>,</span><br><span class="line">        replaceText = ARepText || <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="comment">//repeatStr是在上面定义过的（字符串循环复制），大家注意哦</span></span><br><span class="line">    <span class="keyword">if</span> (regArr.length === <span class="number">3</span> &amp;&amp; type === <span class="number">0</span>) &#123;</span><br><span class="line">        regtext = <span class="string">&#x27;(\\w&#123;&#x27;</span> + regArr[<span class="number">0</span>] + <span class="string">&#x27;&#125;)\\w&#123;&#x27;</span> + regArr[<span class="number">1</span>] + <span class="string">&#x27;&#125;(\\w&#123;&#x27;</span> + regArr[<span class="number">2</span>] + <span class="string">&#x27;&#125;)&#x27;</span></span><br><span class="line">        Reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regtext);</span><br><span class="line">        <span class="keyword">var</span> replaceCount = <span class="built_in">this</span>.repeatStr(replaceText, regArr[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> str.replace(Reg, <span class="string">&#x27;$1&#x27;</span> + replaceCount + <span class="string">&#x27;$2&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (regArr.length === <span class="number">3</span> &amp;&amp; type === <span class="number">1</span>) &#123;</span><br><span class="line">        regtext = <span class="string">&#x27;\\w&#123;&#x27;</span> + regArr[<span class="number">0</span>] + <span class="string">&#x27;&#125;(\\w&#123;&#x27;</span> + regArr[<span class="number">1</span>] + <span class="string">&#x27;&#125;)\\w&#123;&#x27;</span> + regArr[<span class="number">2</span>] + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">        Reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regtext);</span><br><span class="line">        <span class="keyword">var</span> replaceCount1 = <span class="built_in">this</span>.repeatStr(replaceText, regArr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">var</span> replaceCount2 = <span class="built_in">this</span>.repeatStr(replaceText, regArr[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> str.replace(Reg, replaceCount1 + <span class="string">&#x27;$1&#x27;</span> + replaceCount2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (regArr.length === <span class="number">1</span> &amp;&amp; type === <span class="number">0</span>) &#123;</span><br><span class="line">        regtext = <span class="string">&#x27;(^\\w&#123;&#x27;</span> + regArr[<span class="number">0</span>] + <span class="string">&#x27;&#125;)&#x27;</span></span><br><span class="line">        Reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regtext);</span><br><span class="line">        <span class="keyword">var</span> replaceCount = <span class="built_in">this</span>.repeatStr(replaceText, regArr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> str.replace(Reg, replaceCount)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (regArr.length === <span class="number">1</span> &amp;&amp; type === <span class="number">1</span>) &#123;</span><br><span class="line">        regtext = <span class="string">&#x27;(\\w&#123;&#x27;</span> + regArr[<span class="number">0</span>] + <span class="string">&#x27;&#125;$)&#x27;</span></span><br><span class="line">        Reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regtext);</span><br><span class="line">        <span class="keyword">var</span> replaceCount = <span class="built_in">this</span>.repeatStr(replaceText, regArr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> str.replace(Reg, replaceCount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.格式化处理字符串</span></span><br><span class="line"><span class="comment">//ecDo.formatText(&#x27;1234asda567asd890&#x27;)</span></span><br><span class="line"><span class="comment">//result：&quot;12,34a,sda,567,asd,890&quot;</span></span><br><span class="line"><span class="comment">//ecDo.formatText(&#x27;1234asda567asd890&#x27;,4,&#x27; &#x27;)</span></span><br><span class="line"><span class="comment">//result：&quot;1 234a sda5 67as d890&quot;</span></span><br><span class="line"><span class="comment">//ecDo.formatText(&#x27;1234asda567asd890&#x27;,4,&#x27;-&#x27;)</span></span><br><span class="line"><span class="comment">//result：&quot;1-234a-sda5-67as-d890&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">str, size, delimiter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _size = size || <span class="number">3</span>, _delimiter = delimiter || <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> regText = <span class="string">&#x27;\\B(?=(\\w&#123;&#x27;</span> + _size + <span class="string">&#x27;&#125;)+(?!\\w))&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regText, <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> str.replace(reg, _delimiter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.现金额大写转换函数</span></span><br><span class="line"><span class="comment">//ecDo.upDigit(168752632)</span></span><br><span class="line"><span class="comment">//result：&quot;人民币壹亿陆仟捌佰柒拾伍万贰仟陆佰叁拾贰元整&quot;</span></span><br><span class="line"><span class="comment">//ecDo.upDigit(1682)</span></span><br><span class="line"><span class="comment">//result：&quot;人民币壹仟陆佰捌拾贰元整&quot;</span></span><br><span class="line"><span class="comment">//ecDo.upDigit(-1693)</span></span><br><span class="line"><span class="comment">//result：&quot;欠人民币壹仟陆佰玖拾叁元整&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upDigit</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fraction = [<span class="string">&#x27;角&#x27;</span>, <span class="string">&#x27;分&#x27;</span>, <span class="string">&#x27;厘&#x27;</span>];</span><br><span class="line">    <span class="keyword">var</span> digit = [<span class="string">&#x27;零&#x27;</span>, <span class="string">&#x27;壹&#x27;</span>, <span class="string">&#x27;贰&#x27;</span>, <span class="string">&#x27;叁&#x27;</span>, <span class="string">&#x27;肆&#x27;</span>, <span class="string">&#x27;伍&#x27;</span>, <span class="string">&#x27;陆&#x27;</span>, <span class="string">&#x27;柒&#x27;</span>, <span class="string">&#x27;捌&#x27;</span>, <span class="string">&#x27;玖&#x27;</span>];</span><br><span class="line">    <span class="keyword">var</span> unit = [</span><br><span class="line">        [<span class="string">&#x27;元&#x27;</span>, <span class="string">&#x27;万&#x27;</span>, <span class="string">&#x27;亿&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;拾&#x27;</span>, <span class="string">&#x27;佰&#x27;</span>, <span class="string">&#x27;仟&#x27;</span>]</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">var</span> head = n &lt; <span class="number">0</span> ? <span class="string">&#x27;欠人民币&#x27;</span> : <span class="string">&#x27;人民币&#x27;</span>;</span><br><span class="line">    n = <span class="built_in">Math</span>.abs(n);</span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fraction.length; i++) &#123;</span><br><span class="line">        s += (digit[<span class="built_in">Math</span>.floor(n * <span class="number">10</span> * <span class="built_in">Math</span>.pow(<span class="number">10</span>, i)) % <span class="number">10</span>] + fraction[i]).replace(<span class="regexp">/零./</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = s || <span class="string">&#x27;整&#x27;</span>;</span><br><span class="line">    n = <span class="built_in">Math</span>.floor(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; unit[<span class="number">0</span>].length &amp;&amp; n &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> p = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; unit[<span class="number">1</span>].length &amp;&amp; n &gt; <span class="number">0</span>; j++) &#123;</span><br><span class="line">            p = digit[n % <span class="number">10</span>] + unit[<span class="number">1</span>][j] + p;</span><br><span class="line">            n = <span class="built_in">Math</span>.floor(n / <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s = p.replace(<span class="regexp">/(零.)*零$/</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="regexp">/^$/</span>, <span class="string">&#x27;零&#x27;</span>) + unit[<span class="number">0</span>][i] + s;</span><br><span class="line">        <span class="comment">//s = p + unit[0][i] + s;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head + s.replace(<span class="regexp">/(零.)*零元/</span>, <span class="string">&#x27;元&#x27;</span>).replace(<span class="regexp">/(零.)+/g</span>, <span class="string">&#x27;零&#x27;</span>).replace(<span class="regexp">/^整$/</span>, <span class="string">&#x27;零元整&#x27;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//8.保留2位小数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toDecimal2</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="built_in">parseFloat</span>(x);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isNaN</span>(f)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="built_in">Math</span>.round(x * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">var</span> s = f.toString();</span><br><span class="line">  <span class="keyword">var</span> rs = s.indexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (rs &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    rs = s.length;</span><br><span class="line">    s += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (s.length &lt;= rs + <span class="number">2</span>) &#123;</span><br><span class="line">    s += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span>&#123;</span><br><span class="line">	trim,</span><br><span class="line">    changeCase,</span><br><span class="line">    repeatStr,</span><br><span class="line">    replaceAll,</span><br><span class="line">    replaceStr,</span><br><span class="line">    checkPwd,</span><br><span class="line">    formatText,</span><br><span class="line">    upDigit,</span><br><span class="line">    toDecimal2,</span><br><span class="line">    formaDate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="31-vue等单页面应用及其优缺点"><a href="#31-vue等单页面应用及其优缺点" class="headerlink" title="31.vue等单页面应用及其优缺点"></a>31.vue等单页面应用及其优缺点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。</span><br><span class="line"></span><br><span class="line">多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新。</span><br><span class="line"></span><br><span class="line">单页面的优点和缺点：</span><br><span class="line">优点：</span><br><span class="line">1、用户体验好，快，内容的改变不需要重新加载整个页面，对服务器压力较小。</span><br><span class="line">2、前后端分离，比如vue项目</span><br><span class="line">3、完全的前端组件化，前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整；</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1、首次加载页面的时候需要加载大量的静态资源，这个加载时间相对比较长。</span><br><span class="line">2、不利于SEO优化，单页页面，数据在前端渲染，就意味着没有 SEO。</span><br><span class="line">3、页面导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">单页Web应用（single page web application，SPA）：就是只有一个页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说模块化的开发和设计显得相当重要。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">单页Web应用的优点：</span><br><span class="line">1、提供了更加吸引人的用户体验：具有桌面应用的即时性、网站的可移植性和可访问性。</span><br><span class="line">2、单页应用的内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷。</span><br><span class="line">3、单页应用没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象</span><br><span class="line">4、单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍。</span><br><span class="line">5、良好的前后端分离。后端不再负责模板渲染、输出页面工作，后端API通用化，即同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">单页Web应用的缺点：</span><br><span class="line">1、首屏加载慢</span><br><span class="line">2、SEO问题，不利于百度，360等搜索引擎收录。</span><br><span class="line">3、容易造成CSS命名冲突。</span><br><span class="line">4、前进、后退、地址栏、书签等，都需要程序进行管理，页面的复杂度很高，需要一定的技能水平和开发成本高。</span><br></pre></td></tr></table></figure>

<h4 id="32-什么是vue的计算属性？"><a href="#32-什么是vue的计算属性？" class="headerlink" title="32.什么是vue的计算属性？"></a>32.什么是vue的计算属性？</h4><p>计算属性：对于任何复杂的计算逻辑，当前属性值是根据其他属性计算出来的，都应当使用计算属性。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;Hello&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    &#x2F;&#x2F; 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      &#x2F;&#x2F; &#96;this&#96; 指向 vm 实例</span><br><span class="line">      return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="33-vue-cli提供的几种脚手架模板"><a href="#33-vue-cli提供的几种脚手架模板" class="headerlink" title="33.vue-cli提供的几种脚手架模板"></a>33.vue-cli提供的几种脚手架模板</h4><blockquote>
<p>在使用之前，可以先用 vue-list命令查询可用的模板。</p>
</blockquote>
<p><img src="/2020/11/11/vue%E9%9D%A2%E8%AF%95%E9%A2%98/54401a94f5d78ffaeb81cdce614c8078_1144x382.jpeg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vue-cli提供了的常用的脚手架模板：</span><br><span class="line">1.webpack：基于 webpack 和 vue-loader 的目录结构，而且支持热部署、代码检查、测试及 css 抽取。</span><br><span class="line">2.webpack-simple：基于 webpack 和 vue-loader 的目录结构。</span><br><span class="line">3.browerify：基于 Browerfiy 和 vueify(作用于 vue-loader 类似)的结构，支持热部署、代码检查及单元测试。</span><br><span class="line">4.browerify-simple：基于 Browerfiy 和 vueify 的结构。</span><br><span class="line">5.simple：单个引入 Vue.js 的 index.html 页面。</span><br><span class="line"></span><br><span class="line">这里我们主要会使用 webpack 作为常用脚手架，可以运行vue init webpack my-project 来生成项目。</span><br></pre></td></tr></table></figure>

<h4 id="34-vue父组件如何向子组件中传递数据"><a href="#34-vue父组件如何向子组件中传递数据" class="headerlink" title="34.vue父组件如何向子组件中传递数据"></a>34.vue父组件如何向子组件中传递数据</h4><p>1.父组件中使用子组件的时候通过 v-bind 向子组件传递数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 动态赋予一个变量的值 --&gt;</span><br><span class="line">&lt;blog-post v-bind:title&#x3D;&quot;post.title&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br></pre></td></tr></table></figure>

<p>2.子组件中声明props来接收父组件传递过来的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props : [&quot;title&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">export default &#123;</span><br><span class="line">  props : &#123;</span><br><span class="line">  	title:&#123;</span><br><span class="line">    	type:string,</span><br><span class="line">        default:&quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="34-如何在组件中使用全局常量"><a href="#34-如何在组件中使用全局常量" class="headerlink" title="34.如何在组件中使用全局常量"></a>34.如何在组件中使用全局常量</h4><p>第一步，在src下新建const文件夹，然后新建 const.js，并在const.js中设置常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── src</span><br><span class="line">│   ├── const</span><br><span class="line">│   │    ├── const.js</span><br><span class="line">│   │    </span><br><span class="line">│   └── main.js</span><br><span class="line">└── ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;const.js</span><br><span class="line">export default &#123;</span><br><span class="line">    install(Vue,options)&#123;</span><br><span class="line">        Vue.prototype.global &#x3D; &#123;</span><br><span class="line">            title:&#39;全局&#39;,</span><br><span class="line">            isBack: true,</span><br><span class="line">            isAdd:  false,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，在 main.js 下全局引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;引入全局常量</span><br><span class="line">import constant from &#39;.&#x2F;const&#x2F;const.js&#39;</span><br><span class="line">Vue.use(constant);</span><br></pre></td></tr></table></figure>

<p>第三步，即可在 .vue 组件中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过js方式使用：</span><br><span class="line">this.global.title</span><br><span class="line">&#x2F;&#x2F;或在 html 结构中使用</span><br><span class="line">&#123;&#123;global.title&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="35-vue如何禁止弹窗后面的滚动条滚动"><a href="#35-vue如何禁止弹窗后面的滚动条滚动" class="headerlink" title="35.vue如何禁止弹窗后面的滚动条滚动"></a>35.vue如何禁止弹窗后面的滚动条滚动</h4><p>1.设置document的overflow为hidden</p>
<p>2.给document绑定touchmove事件，阻止默认事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">methods : &#123;</span><br><span class="line">   &#x2F;&#x2F;禁止滚动</span><br><span class="line">   stop()&#123;</span><br><span class="line">        var mo&#x3D;function(e)&#123;e.preventDefault();&#125;;</span><br><span class="line">        document.body.style.overflow&#x3D;&#39;hidden&#39;;</span><br><span class="line">        document.addEventListener(&quot;touchmove&quot;,mo,false);&#x2F;&#x2F;禁止页面滑动</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;取消滑动限制</span><br><span class="line">    move()&#123;</span><br><span class="line">        var mo&#x3D;function(e)&#123;e.preventDefault();&#125;;</span><br><span class="line">        document.body.style.overflow&#x3D;&#39;&#39;;&#x2F;&#x2F;出现滚动条</span><br><span class="line">        document.removeEventListener(&quot;touchmove&quot;,mo,false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="36-请说出计算属性-computed-的缓存和方法-method-调用的有什么区别？"><a href="#36-请说出计算属性-computed-的缓存和方法-method-调用的有什么区别？" class="headerlink" title="36.请说出计算属性(computed)的缓存和方法(method)调用的有什么区别？"></a>36.请说出计算属性(computed)的缓存和方法(method)调用的有什么区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 计算属性必须返回结果</span><br><span class="line">2. 计算属性是基于它的依赖缓存的。一个计算属性所依赖的数据发生变化时，它才会重新取值。</span><br><span class="line">3. 使用计算属性还是methods取决于是否需要缓存，当遍历大数组和做大量计算时，应当使用计算属性，除非你不希望得到缓存。</span><br><span class="line">4. 计算属性是根据依赖自动执行的，methods需要事件调用。</span><br></pre></td></tr></table></figure>

<h4 id="37-什么是vue-js中的自定义指令"><a href="#37-什么是vue-js中的自定义指令" class="headerlink" title="37.什么是vue.js中的自定义指令"></a>37.什么是vue.js中的自定义指令</h4><p>Vue里面有许多内置的指令，比如<code>v-if</code>和<code>v-show</code>，这些丰富的指令能满足我们的绝大部分业务需求，不过在需要一些特殊功能时，我们仍然希望对<code>DOM</code>进行底层的操作，这时就要用到自定义指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&#39;focus&#39;, &#123;</span><br><span class="line">    bind: function (el) &#123; </span><br><span class="line">        &#x2F;&#x2F; 每当指令绑定到元素上的时候，会立即执行这个bind 函数，只执行一次</span><br><span class="line">        &#x2F;&#x2F; 注意： 在每个函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数，是一个原生的JS对象</span><br><span class="line">        &#x2F;&#x2F; 在元素刚绑定了指令的时候还没有插入到DOM中去的时候调用focus方法没有作用。因为，一个元素只有插入DOM之后才能获取焦点</span><br><span class="line">        &#x2F;&#x2F; el.focus()</span><br><span class="line">    &#125;,</span><br><span class="line">    inserted: function (el) &#123;  </span><br><span class="line">        &#x2F;&#x2F; inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】。和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效</span><br><span class="line">        el.focus()</span><br><span class="line">    &#125;,</span><br><span class="line">    updated: function (el) &#123;  </span><br><span class="line">        &#x2F;&#x2F; 当VNode更新的时候，会执行 updated， 可能会触发多次</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="38-自定义指令的几个钩子函数"><a href="#38-自定义指令的几个钩子函数" class="headerlink" title="38.自定义指令的几个钩子函数"></a>38.自定义指令的几个钩子函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span><br><span class="line">- inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</span><br><span class="line">- update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。</span><br><span class="line">- componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</span><br><span class="line">- unbind：只调用一次，指令与元素解绑时调用。</span><br><span class="line"></span><br><span class="line">bind(vnode,binding)&#123;</span><br><span class="line">    &#x2F;&#x2F;vnode是绑定指定的那个元素</span><br><span class="line">    &#x2F;&#x2F;binding里面包含指定所绑定的信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="39-自定义指令钩子函数参数"><a href="#39-自定义指令钩子函数参数" class="headerlink" title="39.自定义指令钩子函数参数"></a>39.自定义指令钩子函数参数</h4><blockquote>
<p>在自定义指令钩子函数的参数中，除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。</p>
</blockquote>
<p>指令钩子函数会被传入以下参数：</p>
<ul>
<li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM 。</li>
<li><code>binding</code>：一个对象，包含以下属性：<ul>
<li>name：指令名，不包括 v- 前缀。</li>
<li>value：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为<code>2</code>。</li>
<li>oldValue：指令绑定的前一个值，仅在<code>update</code>和 <code>componentUpdated</code>钩子中可用。无论值是否改变都可用。</li>
<li>expression：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li>
<li>arg：传给指令的参数，可选。例如 <code>v-my-directive:foo</code>中，参数为 “foo”。</li>
<li>modifiers：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为<code>&#123; foo: true, bar: true &#125;</code>。</li>
</ul>
</li>
<li><code>vnode</code>：Vue 编译生成的虚拟节点。</li>
<li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li>
</ul>
<h4 id="40-vue-router如何响应路由参数的变化"><a href="#40-vue-router如何响应路由参数的变化" class="headerlink" title="40.vue-router如何响应路由参数的变化"></a>40.vue-router如何响应路由参数的变化</h4><blockquote>
<p>问题：当使用路由参数时，例如从 <code>/content?id=1</code> 到 <code>content?id=2</code>，此时原来的组件实例会被复用。这也意味着组件的<code>生命周期钩子不会再被调用</code>，此时vue应该如何响应<code>路由参数</code> 的变化？</p>
</blockquote>
<p>解决方案：</p>
<p>1.用 :key 来阻止“复用”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在父组件中使用</span><br><span class="line">&lt;router-view :key&#x3D;&quot;key&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">	key() &#123;</span><br><span class="line">		return this.$route.name !&#x3D;&#x3D; undefined? this.$route.name +new Date(): this.$route +new Date()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这种办法实质上是让每次路由跳转时重新构建该组件，我们在它的生命周期中写一个打印语句就能看出来。</span><br></pre></td></tr></table></figure>

<p>2.复用组件时，想对路由参数的变化作出响应的话， 可以<code>watch (监测变化) $route 对象</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">&#x27;$route&#x27;</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.通过 <code>vue-router </code>的钩子函数 <code>beforeRouteEnter </code> <code>beforeRouteUpdate</code>  <code>beforeRouteLeave</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">   <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">   <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">   <span class="comment">// 因为当钩子执行前，组件实例还没被创建</span></span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">   <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">   <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">   <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">   <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">   <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">   <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="41-完整的-vue-router-导航解析流程"><a href="#41-完整的-vue-router-导航解析流程" class="headerlink" title="41.完整的 vue-router 导航解析流程"></a>41.完整的 vue-router 导航解析流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">当由A路由 --&gt; B路由的时候：</span><br><span class="line">1、在A组件里调用离开守卫。          A组件中的  beforeRouteLeave </span><br><span class="line">2、调用全局的 beforeEach 守卫。    router.beforeEach</span><br><span class="line">3、再执行B路由配置里调用 beforeEnter。</span><br><span class="line">      routes: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#39;&#x2F;b&#39;,</span><br><span class="line">          component: B,</span><br><span class="line">          beforeEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">4、再执行B组件的进入守卫。          B组件中 beforeRouteEnter。</span><br><span class="line">5、调用全局的 beforeResole 守卫 (2.5+)。    router.beforeResolve</span><br><span class="line">6、导航被确认。</span><br><span class="line">7、调用全局的 afterEach 钩子。              router.afterEach</span><br><span class="line">8、触发 DOM 更新。</span><br></pre></td></tr></table></figure>

<h4 id="42-vue-router有哪几种导航钩子（-导航守卫-）？"><a href="#42-vue-router有哪几种导航钩子（-导航守卫-）？" class="headerlink" title="42.vue-router有哪几种导航钩子（ 导航守卫 ）？"></a>42.vue-router有哪几种导航钩子（ 导航守卫 ）？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">1、全局守卫： router.beforeEach  router.beforeResolve  router.afterEach</span><br><span class="line">    const router &#x3D; new VueRouter(&#123; ... &#125;);</span><br><span class="line">    router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; do someting</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;to:代表要进入的目标，它是一个路由对象</span><br><span class="line">    &#x2F;&#x2F;from:代表当前正要离开的路由，同样也是一个路由对象</span><br><span class="line">    &#x2F;&#x2F;next:这是一个必须需要调用的方法，而具体的执行效果则依赖 next 方法调用的参数</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;全局后置钩子，后置钩子并没有 next 函数，也不会改变导航本身</span><br><span class="line">    router.afterEach((to, from) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; do someting</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">2、路由独享的守卫： beforeEnter</span><br><span class="line">    cont router &#x3D; new VueRouter(&#123;</span><br><span class="line">        routes: [</span><br><span class="line">            &#123;</span><br><span class="line">                path: &#39;&#x2F;file&#39;,</span><br><span class="line">                component: File,</span><br><span class="line">                beforeEnter: (to, from ,next) &#x3D;&gt; &#123;</span><br><span class="line">                    &#x2F;&#x2F; do someting</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">3、组件内的守卫： beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave</span><br><span class="line">    const File &#x3D; &#123;</span><br><span class="line">        template: &#96;&lt;div&gt;This is file&lt;&#x2F;div&gt;&#96;,</span><br><span class="line">        beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">            &#x2F;&#x2F; do someting</span><br><span class="line">            &#x2F;&#x2F; 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeRouteUpdate(to, from, next) &#123;</span><br><span class="line">            &#x2F;&#x2F; do someting</span><br><span class="line">            &#x2F;&#x2F; 在当前路由改变，但是依然渲染该组件是调用</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeRouteLeave(to, from ,next) &#123;</span><br><span class="line">            &#x2F;&#x2F; do someting</span><br><span class="line">            &#x2F;&#x2F; 导航离开该组件的对应路由时被调用</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="43-vue-router的几种实例方法以及参数传递"><a href="#43-vue-router的几种实例方法以及参数传递" class="headerlink" title="43.vue-router的几种实例方法以及参数传递"></a>43.vue-router的几种实例方法以及参数传递</h4><table>
<thead>
<tr>
<th>实例方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>this.$router.push(location, onComplete?, onAbort?)</td>
<td>这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。并且点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code>等同于调用 <code>router.push(...)</code>。</td>
</tr>
<tr>
<td>this.$router.replace(location, onComplete?, onAbort?)</td>
<td>这个方法不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录，所以，当用户点击浏览器后退按钮时，并不会回到之前的 URL。</td>
</tr>
<tr>
<td>this.$router.go(n)</td>
<td>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 <code>window.history.go(n)</code>。</td>
</tr>
</tbody></table>
<p><strong>参数传递方式：</strong>vue-router提供了<code>params</code>、<code>query</code>、<code>meta</code>三种页面间传递参数的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符串，不带参数</span><br><span class="line">this.$router.push(&#39;home&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象，不带参数</span><br><span class="line">this.$router.push(&#123; path: &#39;home&#39; &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; params（推荐）：命名的路由，params 必须和 name 搭配使用</span><br><span class="line">this.$router.push(&#123; name:&#39;user&#39;,params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里的 params 不生效</span><br><span class="line">this.$router.push(&#123; path:&#39;&#x2F;user&#39;,params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; query：带查询参数，变成 &#x2F;register?plan&#x3D;private</span><br><span class="line">this.$router.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;meta方式：路由元信息</span><br><span class="line">export default new Router(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &#39;&#x2F;user&#39;,</span><br><span class="line">            name: &#39;user&#39;,</span><br><span class="line">            component: user,</span><br><span class="line">            meta:&#123;</span><br><span class="line">                title:&#39;个人中心&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在组件中获取路由参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过 $route 对象获取，注意是route，不是$router</span><br><span class="line">this.$route.params</span><br><span class="line">this.$route.query</span><br><span class="line">this.$route.meta</span><br></pre></td></tr></table></figure>

<h4 id="44-route-和-router-的区别"><a href="#44-route-和-router-的区别" class="headerlink" title="44.$route 和 $router 的区别"></a>44.$route 和 $router 的区别</h4><p><code>$route</code>是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</p>
<p><code>$router</code>是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p>
<h4 id="45-vue-router的动态路由匹配以及使用"><a href="#45-vue-router的动态路由匹配以及使用" class="headerlink" title="45.vue-router的动态路由匹配以及使用"></a>45.vue-router的动态路由匹配以及使用</h4><p>动态路径匹配：即把某种模式匹配到的所有路由，全都映射到同个组件。使用动态路由参数来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const User &#x3D; &#123;</span><br><span class="line">  template: &#39;&lt;div&gt;User&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#x2F;&#x2F; 动态路径参数 以冒号开头</span><br><span class="line">    &#123; path: &#39;&#x2F;user&#x2F;:id&#39;, component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  这样，像&#x2F;user&#x2F;foo和&#x2F;user&#x2F;bar都将映射到相同的路由。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;一个“路径参数”使用冒号 :标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。</span><br><span class="line"></span><br><span class="line">const User &#x3D; &#123;</span><br><span class="line">  template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="46-vue-router如何定义嵌套路由"><a href="#46-vue-router如何定义嵌套路由" class="headerlink" title="46.vue-router如何定义嵌套路由"></a>46.vue-router如何定义嵌套路由</h4><p>嵌套路由  :  是路由的多层嵌套。</p>
<p><code>第一步：</code>需要在一个被渲染的组件中嵌套 <code>&lt;router-view&gt;</code>组件用于呈现子路由。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const User &#x3D; &#123;</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;div class&#x3D;&quot;user&quot;&gt;</span><br><span class="line">      &lt;h2&gt;User&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>第二步：</code>在嵌套的出口中渲染组件，在<code>VueRouter</code> 的参数中使用<code>children</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: &#39;&#x2F;user&#x2F;:id&#39;, </span><br><span class="line">      component: User,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;&#x2F; 当 &#x2F;user&#x2F;:id&#x2F;profile 匹配成功，</span><br><span class="line">          &#x2F;&#x2F; UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中</span><br><span class="line">          path: &#39;profile&#39;,</span><br><span class="line">          component: UserProfile</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;&#x2F; 当 &#x2F;user&#x2F;:id&#x2F;posts 匹配成功</span><br><span class="line">          &#x2F;&#x2F; UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中</span><br><span class="line">          path: &#39;posts&#39;,</span><br><span class="line">          component: UserPosts</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="47-lt-router-link-gt-lt-router-link-gt-组件及其属性"><a href="#47-lt-router-link-gt-lt-router-link-gt-组件及其属性" class="headerlink" title="47.&lt;router-link&gt;&lt;/router-link&gt;组件及其属性"></a>47.<code>&lt;router-link&gt;&lt;/router-link&gt;</code>组件及其属性</h4><p><code>&lt;router-link&gt; 组件:</code>用于支持用户在具有路由功能的应用中 (点击)跳转导航。</p>
<p>可以通过<code>to 属性</code>指定目标地址，默认渲染成带有正确链接的 <code>&lt;a&gt; 标签，</code>可以通过配置 <code>tag 属性</code>生成别的标签.。</p>
<p>另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。</p>
<p><strong>常用属性：</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>to</td>
<td>string \ Location</td>
<td>表示目标路由的链接。当被点击后，内部会立刻把<code>to</code>的值传到<code>router.push()</code>，所以这个值可以是一个字符串或者是描述目标位置的对象。</td>
<td><code>&lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;</code></td>
</tr>
<tr>
<td>replace</td>
<td>boolean（默认flase）</td>
<td>设置<code>replace</code>属性的话，当点击时，会调用 <code>router.replace()</code>而不是 router.push()，于是导航后<code>不会留下 history 记录</code>。</td>
<td><code>&lt;router-link :to=&quot;&#123; path: &#39;/abc&#39;&#125;&quot; replace&gt;&lt;/router-link&gt;</code></td>
</tr>
<tr>
<td>append</td>
<td>boolean（默认flase）</td>
<td>设置<code>append</code>属性后，则在当前 (相对) 路径前添加基路径。例如，我们从 <code>/a</code>导航到一个相对路径 <code>b</code>，如果<code>没有配置 append</code>，则路径为<code>/b</code>，如果<code>配了</code>，则为<code>/a/b</code></td>
<td><code>&lt;router-link :to=&quot;&#123; path: &#39;relative/path&#39;&#125;&quot; append&gt;&lt;/router-link&gt;</code></td>
</tr>
<tr>
<td>tag</td>
<td>string（默认 ‘a’）</td>
<td>有时候想要 渲染成某种标签，例如 <code>&lt;li&gt;</code>于是我们使用<code>tag</code>prop 类指定何种标签，同样它还是<code>会监听点击</code>，触发导航。</td>
<td><code>&lt;router-link to=&quot;/foo&quot; tag=&quot;li&quot;&gt;foo&lt;/router-link&gt;</code></td>
</tr>
<tr>
<td>active-class</td>
<td>string（默认 “router-link-active”）</td>
<td>设置 <code>链接激活时</code>使用的<code>CSS 类名</code>。默认值可以通过路由的构造选项<code>linkActiveClass</code>来全局配置。</td>
<td></td>
</tr>
<tr>
<td>exact</td>
<td>boolean（默认 false）</td>
<td>“是否激活” 默认类名的依据是 <code>inclusive match (全包含匹配)</code>。 举个例子，如果当前的路径是 /a 开头的，那么 也会被设置 CSS 类名。</td>
<td><code>这个链接只会在地址为 / 的时候被激活： &lt;router-link to=&quot;/&quot; exact&gt;</code></td>
</tr>
<tr>
<td>event</td>
<td>string \ Array （默认 ‘click’）</td>
<td>声明可以用来<code>触发导航的事件</code>。可以是一个<code>字符串</code>或是一个包含<code>字符串的数组</code>。</td>
<td></td>
</tr>
<tr>
<td>exact-active-class</td>
<td>string 默认 ‘router-link-exact-active’</td>
<td>配置当链接被精确匹配的时候应该激活的 <code>class</code>。注意默认值也是可以通过路由构造函数选项<code>linkExactActiveClass</code>进行全局配置的。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="48-vue-router实现动态加载路由组件（-懒加载-）"><a href="#48-vue-router实现动态加载路由组件（-懒加载-）" class="headerlink" title="48.vue-router实现动态加载路由组件（ 懒加载 ）"></a>48.vue-router实现动态加载路由组件（ 懒加载 ）</h4><p>当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>
<p>结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。</p>
<p>第一步：定义一个能够被 Webpack 自动代码分割的异步组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在src&#x2F;router&#x2F;index.js里面引入异步引入组件</span><br><span class="line">const index &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;page&#x2F;list&#x2F;index.vue&#39;);</span><br></pre></td></tr></table></figure>

<p>第二步：在路由配置中什么都不需要改变，只需要像往常一样使用 index。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#39;&#x2F;index&#39;, component: index,name:&quot;index&quot; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>第三步：在build/webpack.base.conf.js下的output属性，新增chunkFilename。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    filename: &#39;[name].js&#39;,</span><br><span class="line">    &#x2F;&#x2F;新增chunkFilename属性</span><br><span class="line">    chunkFilename: &#39;[name].js&#39;,</span><br><span class="line">    publicPath: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">      ? config.build.assetsPublicPath</span><br><span class="line">      : config.dev.assetsPublicPath</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="49-什么是vuex？"><a href="#49-什么是vuex？" class="headerlink" title="49.什么是vuex？"></a>49.什么是vuex？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vuex 是一个专为 Vue.js 应用程序开发的状态管理器，采用集中式存储管理所有组件的状态。</span><br><span class="line"></span><br><span class="line">vuex的原理其实非常简单，它为什么能实现所有的组件共享同一份数据？</span><br><span class="line">因为vuex生成了一个store实例，并且把这个实例挂在了所有的组件上，所有的组件引用的都是同一个store实例。</span><br><span class="line">store实例上有数据，有方法，方法改变的都是store实例上的数据。由于其他组件引用的是同样的实例，所以一个组件改变了store上的数据，导致另一个组件上的数据也会改变，就像是一个对象的引用。</span><br></pre></td></tr></table></figure>

<h4 id="50-使用vuex的核心概念"><a href="#50-使用vuex的核心概念" class="headerlink" title="50.使用vuex的核心概念"></a>50.使用vuex的核心概念</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。</span><br><span class="line"></span><br><span class="line"><span class="comment">//vuex的核心概念和核心概念图：</span></span><br><span class="line"><span class="number">1</span>、state - Vuex store实例的根状态对象，用于定义共享的状态变量。</span><br><span class="line"><span class="number">2</span>、Action -动作，向store发出调用通知，执行本地或者远端的某一个操作（可以理解为store的methods）</span><br><span class="line"><span class="number">3</span>、Mutations -修改器，它只用于修改state中定义的状态变量。</span><br><span class="line"><span class="number">4</span>、getter -读取器，外部程序通过它获取变量的具体值，或者在取值前做一些计算（可以认为是store的计算属性）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Vuex的应用场景：</span></span><br><span class="line">Vuex主要用于：</span><br><span class="line"> <span class="number">1</span>、多层嵌套的组件之间进行状态传递</span><br><span class="line"> <span class="number">2</span>、兄弟组件间进行状态传递时（当然也可以使用中央事件总线BUS）</span><br><span class="line"> <span class="number">3</span>、多组件共享状态时</span><br><span class="line"> </span><br><span class="line">更为具体的场景：组件之间的状态、音乐播放、登录状态、加入购物车...</span><br></pre></td></tr></table></figure>



<p><img src="/2020/11/11/vue%E9%9D%A2%E8%AF%95%E9%A2%98/288a0dc913bab3fe765baf18fb4bac27_701x551.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vuex的使用</span></span><br><span class="line"></span><br><span class="line">#1.安装vuex</span><br><span class="line"> npm i vuex -S</span><br><span class="line"></span><br><span class="line">#2.main.js</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册vuex到vue中</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// new Vuex.Store()实例，得到一个数据仓储对象</span></span><br><span class="line"><span class="comment">// 可以在组件中通过this.$store.state.xx 来访问store中的数据</span></span><br><span class="line"><span class="keyword">var</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="comment">//state相当于组件中的data</span></span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//如果要修改store中state的值，需要调用 mutations提供的方法，可以通过this.$store.commit(&#x27;方法名&#x27;)来调用</span></span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//mutations函数参数列表中最多支持两个参数，其中参数1是state； 参数2是通过commit提交过来的参数；</span></span><br><span class="line">        <span class="function"><span class="title">subtract</span>(<span class="params">state, obj</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(obj)</span><br><span class="line">            state.count -= obj.step;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        <span class="comment">//这里的getters只负责对外提供数据，不负责修改数据，如果想要修改 state 中的数据需要在mutations中修改</span></span><br><span class="line">        optCount: <span class="function"><span class="keyword">function</span> (<span class="params">state</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;当前最新的count值是：&#x27;</span> + state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结：</span></span><br><span class="line"><span class="comment">// 1. state中的数据，不能直接修改，如果想要修改，必须通过 mutations</span></span><br><span class="line"><span class="comment">// 2. 如果组件想要直接 从 state 上获取数据： 需要 this.$store.state.***</span></span><br><span class="line"><span class="comment">// 3. 如果组件想要修改数据，必须使用 mutations 提供的方法，需要通过 this.$store.commit(&#x27;方法的名称&#x27;， 唯一的一个参数)</span></span><br><span class="line"><span class="comment">// 4. store中state上的数据在对外提供的时候建议做一层包装，推荐使用 getters。调用的时候则用this.$store.getters.***</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    render: <span class="function"><span class="params">c</span> =&gt;</span> c(App),</span><br><span class="line">    <span class="comment">//将vuex创建的store挂载到VM实例上，只要挂载到了 vm 上，任何组件都能使用store来存取数据</span></span><br><span class="line">    store</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#3.index.html</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">#4.App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;这是 App 组件&lt;/h1&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;counter&gt;&lt;/counter&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;amount&gt;&lt;/amount&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> counter <span class="keyword">from</span> <span class="string">&quot;./components/counter.vue&quot;</span>;</span><br><span class="line">    <span class="keyword">import</span> amount <span class="keyword">from</span> <span class="string">&quot;./components/amount.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            counter,</span><br><span class="line">            amount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">#5.components/amount.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123; $store.getters.optCount &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">#6.components/counter.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;绑定事件-减少&quot;</span> @click=<span class="string">&quot;sub&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;绑定事件-增加&quot;</span> @click=<span class="string">&quot;add&quot;</span>&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;$store.state.count&quot;</span>&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.$store.commit(<span class="string">&quot;increment&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">sub</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;subtract&quot;</span>,&#123; <span class="attr">step</span>:<span class="number">3</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="51-如何在vuex中使用异步修改？"><a href="#51-如何在vuex中使用异步修改？" class="headerlink" title="51.如何在vuex中使用异步修改？"></a>51.如何在vuex中使用异步修改？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们可以在vuex的action中实现对vuex的异步修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="function"><span class="title">asyncInCrement</span>(<span class="params">&#123; commit &#125;, n</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                commit(types.TEST_INCREMENT, n);</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;,<span class="number">3000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="52-Promise对象是什么？"><a href="#52-Promise对象是什么？" class="headerlink" title="52.Promise对象是什么？"></a>52.Promise对象是什么？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Promise对象是ES6（ ECMAScript 2015 ）对于异步编程提供的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。</span><br><span class="line">Promise本身不是异步的，只不过Promise中可以有异步任务，new Promise()的第一个函数参数是立马执行的。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    	<span class="function"><span class="title">if</span>(<span class="params">a &gt; <span class="number">10</span></span>)</span>&#123;</span><br><span class="line">        	resolve(a)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	reject(b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func1(<span class="string">&#x27;11&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise构造函数接受一个函数作为参数，该函数的两个参数分别resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供。</span></span><br><span class="line"><span class="number">1.</span>resolve函数的作用是： 将<span class="built_in">Promise</span>对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>reject函数的作用是： 将<span class="built_in">Promise</span>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise对象实例的方法，then 和 catch：</span></span><br><span class="line"><span class="number">1</span>  .then方法： 用于指定调用成功时的回调函数。</span><br><span class="line">	then方法返回的是一个新的<span class="built_in">Promise</span>实例（注意，不是原来那个<span class="built_in">Promise</span>实例），因此可以采用链式写法，即then方法后面再调用另一个then方法。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>  .catch方法： 用于指定发生错误时的回调函数。</span><br></pre></td></tr></table></figure>

<h4 id="53-axios、fetch与ajax有什么区别？"><a href="#53-axios、fetch与ajax有什么区别？" class="headerlink" title="53.axios、fetch与ajax有什么区别？"></a>53.axios、fetch与ajax有什么区别？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Ajax</span></span><br><span class="line">Ajax指的是XMLHttpRequest（XHR）， 最早出现的发送后端请求技术，核心使用XMLHttpRequest对象，如果多个请求之间有先后关系的话，就会出现回调地狱。</span><br><span class="line"></span><br><span class="line">JQuery ajax 是对原生XHR的封装，除此以外还增添了对JSONP的支持。经过多年的更新维护，真的已经是非常的方便了，优点无需多言</span><br><span class="line"></span><br><span class="line">Ajax的缺点：</span><br><span class="line"><span class="number">1.</span>本身是针对MVC的编程,不符合现在前端MVVM的浪潮</span><br><span class="line"><span class="number">2.</span>基于原生的XHR开发，XHR本身的架构不清晰。</span><br><span class="line"><span class="number">3.</span>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）</span><br><span class="line"><span class="number">4.</span>容易出现回调地狱的问题</span><br><span class="line"><span class="number">5.</span>不符合关注分离的原则</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.axios</span></span><br><span class="line">Vue2<span class="number">.0</span>之后，尤雨溪推荐我们使用axios替换JQuery ajax。</span><br><span class="line">axios 是一个基于<span class="built_in">Promise</span>的请求库，用于浏览器和nodejs中，本质上浏览器的axios也是对原生XHR的封装，只不过它是<span class="built_in">Promise</span>的实现版本，符合最新的ES规范，它本身具有以下特征：</span><br><span class="line"><span class="number">1.</span>从浏览器中创建 XMLHttpRequest</span><br><span class="line"><span class="number">2.</span>支持 <span class="built_in">Promise</span> API</span><br><span class="line"><span class="number">3.</span>客户端支持防止CSRF</span><br><span class="line"><span class="number">4.</span>提供了一些并发请求的接口（重要，方便了很多的操作）</span><br><span class="line"><span class="number">5.</span>从node.js创建 http 请求</span><br><span class="line"><span class="number">6.</span>拦截请求和响应</span><br><span class="line"><span class="number">7.</span>转换请求和响应数据</span><br><span class="line"><span class="number">8.</span>取消请求</span><br><span class="line"><span class="number">9.</span>自动转换<span class="built_in">JSON</span>数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.fetch</span></span><br><span class="line">fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的，Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</span><br><span class="line"></span><br><span class="line">fetch的优点：</span><br><span class="line"><span class="number">1.</span>符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里</span><br><span class="line"><span class="number">2.</span>更好更方便的写法</span><br><span class="line"><span class="number">3.</span>基于标准 <span class="built_in">Promise</span> 实现，支持 <span class="keyword">async</span>/<span class="keyword">await</span></span><br><span class="line"><span class="number">4.</span>更加底层，提供的API丰富（request, response）</span><br><span class="line"><span class="number">5.</span>脱离了XHR，是ES6规范里新的实现方式</span><br></pre></td></tr></table></figure>

<h4 id="54-axios有什么特点？"><a href="#54-axios有什么特点？" class="headerlink" title="54.axios有什么特点？"></a>54.axios有什么特点？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API</span><br><span class="line">2、它可以拦截请求和响应</span><br><span class="line">3、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据</span><br><span class="line">4、安全性更高，客户端支持防御 XSRF</span><br><span class="line">5、在客户端和服务器均可使用</span><br></pre></td></tr></table></figure>

<h4 id="55-vue组件的scoped属性的作用"><a href="#55-vue组件的scoped属性的作用" class="headerlink" title="55.vue组件的scoped属性的作用"></a>55.vue组件的scoped属性的作用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当 &lt;style&gt; 标签有scoped 属性时，它的 CSS 只作用于当前组件中的元素</span><br><span class="line">你可以在一个组件中同时使用有 scoped 和 非scoped 样式：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&#x2F;* 全局样式 *&#x2F;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&#x2F;* 本地样式 *&#x2F;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h4 id="56-vue中集成的UI组件库"><a href="#56-vue中集成的UI组件库" class="headerlink" title="56.vue中集成的UI组件库"></a>56.vue中集成的UI组件库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">常用的UI组件库有：</span><br><span class="line">vux： Vue.js 移动端 UI 组件库</span><br><span class="line">Amaze ~ 妹子 UI</span><br><span class="line">Element：饿了么组件库，适用于开发应用后台</span><br><span class="line">mint-ui：移动端 UI 组件库</span><br><span class="line">Ant-design : 阿里的UI组件库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1.安装第三方组件库  </span><br><span class="line">2.引入组件库的包    Vue.use()</span><br><span class="line">3.引入组件的css文件</span><br><span class="line">4.使用</span><br><span class="line">5.按需加载   安装babel插件   配置babelrc文件    用什么组件引入什么组件</span><br></pre></td></tr></table></figure>

<h4 id="57-如何适配移动端？【-经典-】"><a href="#57-如何适配移动端？【-经典-】" class="headerlink" title="57.如何适配移动端？【 经典 】"></a>57.如何适配移动端？【 经典 】</h4><p><strong>在css样式兼容性方面，我们可以使用autoprefixer插件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postcss可以被理解为一个平台，可以让一些插件在上面跑。它提供了一个解析器，可以将CSS解析成抽象语法树。通过PostCSS这个平台，我们能够开发一些插件，来处理CSS。热门插件如autoprefixer。</span><br><span class="line"></span><br><span class="line">vue-cli已经自动集成了postcss，所以我们可以在postcss.config.js这个配置文件中直接添加autoprefixer这个插件</span><br></pre></td></tr></table></figure>

<p><strong>在屏幕大小适配方面，我们可以使用下面两种方案</strong></p>
<p>a) 使用flexible和 postcss-px2rem</p>
<pre><code>之前使用rem适配的思路：使用媒体查询，确定不同屏幕下html标签的font-size  (即1rem单位)，然后在写css样式的时候，就可以使用1rem , 2rem这样的单位来做适配了。

但是这种适配的问题是需要手动把px单位换算成rem单位，比较麻烦。对应的，我们可以使用flexible和 postcss-px2rem来解决这个问题</code></pre>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.安装flexible。 flexible主要是实现在各种不同的移动端界面实现一稿搞定所有的设备兼容自适应问题</span></span><br><span class="line">npm install lib-flexible --save</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.main.js引入flexible</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lib-flexible&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时运行程序会看到html中自动加上了font-size    font-size的默认值为viewport的十分之一</span></span><br><span class="line"><span class="comment">//在页面中引入flexible.js后，flexible会在&lt;html&gt;标签上增加一个data-dpr属性和font-size样式（如下图）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.安装postcss-pxtorem</span></span><br><span class="line">npm install postcss-pxtorem --save-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.修改postcss.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    <span class="comment">//autoprefixer 自动补全css前缀的东西</span></span><br><span class="line">    <span class="string">&#x27;autoprefixer&#x27;</span>: &#123;</span><br><span class="line">      <span class="comment">//兼容的机型</span></span><br><span class="line">      browsers: [<span class="string">&#x27;Android &gt;= 4.0&#x27;</span>, <span class="string">&#x27;iOS &gt;= 7&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;postcss-pxtorem&#x27;</span>: &#123;</span><br><span class="line">      rootValue: <span class="number">37.5</span>, <span class="comment">//换算基数，一般和html的font-size一致</span></span><br><span class="line">      propList: [<span class="string">&#x27;*&#x27;</span>]  <span class="comment">//哪些css属性需要换算</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>b) 使用postcss-px-to-viewport</p>
<pre><code>`vw` 与 `vh`单位，以`viewport`为基准，`1vw` 与 `1vh`分别为`window.innerWidth` 与 `window.innerHeight`的百分之一。

vw/vh 单位其实出现比较早了，只是以前支持性不太好，现在随着浏览器的发展，大部分（92%以上）的浏览器已经支持了vw/vh</code></pre>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">npm i postcss-px-to-viewport -save -dev</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改postcss.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">      autoprefixer: &#123;</span><br><span class="line">          <span class="comment">//兼容的机型</span></span><br><span class="line">      	  browsers: [<span class="string">&#x27;Android &gt;= 4.0&#x27;</span>, <span class="string">&#x27;iOS &gt;= 7&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">    <span class="comment">//px转换为vw单位的插件</span></span><br><span class="line">    <span class="string">&quot;postcss-px-to-viewport&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">//1vw = 3.2</span></span><br><span class="line">      viewportWidth: <span class="number">320</span>,</span><br><span class="line">      <span class="comment">//1vh = 5.68</span></span><br><span class="line">      viewportHeight: <span class="number">568</span>,</span><br><span class="line">      <span class="comment">// px to vw无法整除时，保留几位小数</span></span><br><span class="line">      unitPrecision: <span class="number">5</span>,</span><br><span class="line">      <span class="comment">// 转换成vw单位   </span></span><br><span class="line">      viewportUnit: <span class="string">&#x27;vw&#x27;</span>,</span><br><span class="line">     <span class="comment">//不转换的类名</span></span><br><span class="line">      selectorBlackList: [],</span><br><span class="line">      <span class="comment">// 小于1px不转换</span></span><br><span class="line">      minPixelValue: <span class="number">1</span>,</span><br><span class="line">     <span class="comment">//允许媒体查询中转换</span></span><br><span class="line">      mediaQuery: <span class="literal">false</span>,</span><br><span class="line">      <span class="comment">//排除node_modules文件中第三方css文件</span></span><br><span class="line">      exclude: <span class="regexp">/(\/|\\)(node_modules)(\/|\\)/</span>  </span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="58-vue-cli工程中如何使用背景图？"><a href="#58-vue-cli工程中如何使用背景图？" class="headerlink" title="58.vue-cli工程中如何使用背景图？"></a>58.vue-cli工程中如何使用背景图？</h4><blockquote>
<p>第一种方法：通过 <code>import</code> 引入</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先，引入要使用的背景图片：</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    import  cover  from  &quot;..&#x2F;assets&#x2F;images&#x2F;cover.png&quot;;</span><br><span class="line">    export  default&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">然后，通过 v-bind:style 使用：</span><br><span class="line">&lt;div :style&#x3D;&quot;&#123; backgroundImage:&#39;url(&#39; + cover + &#39;)&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二种方法：通过 <code>require</code> 引入：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接通过 v-bind 和 require 配合使用</span><br><span class="line"></span><br><span class="line">&lt;div :style&#x3D;&quot;&#123; backgroundImage:&#39;url(&#39; + require(&#39;..&#x2F;assets&#x2F;images&#x2F;couver.png&#39;) + &#39;)&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>如果在css文件中使用图片作为背景，可以直接 background:url(../../logg.png)</p>
<h4 id="59-vue中如何实现tab切换功能？"><a href="#59-vue中如何实现tab切换功能？" class="headerlink" title="59.vue中如何实现tab切换功能？"></a>59.vue中如何实现tab切换功能？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在 vue 中，实现 Tab 切换主要有三种方式：</span><br><span class="line">1、使用 component 动态组件实现 Tab切换 [推荐移动端使用]</span><br><span class="line">   &lt;component :is&#x3D;&quot;组件名字&quot;&gt;&lt;&#x2F;component&gt;</span><br><span class="line">2、使用 vue-router 路由配合&lt;router-view&gt;&lt;&#x2F;router-view&gt;标签实现</span><br><span class="line">3、使用第三方组件</span><br><span class="line">4、还可以通过v-if和v-show来完成</span><br></pre></td></tr></table></figure>

<h4 id="60-vue中如何利用-lt-keep-alive-gt-lt-keep-alive-gt-标签实现某个组件缓存功能？"><a href="#60-vue中如何利用-lt-keep-alive-gt-lt-keep-alive-gt-标签实现某个组件缓存功能？" class="headerlink" title="60.vue中如何利用&lt;keep-alive&gt;&lt;/keep-alive&gt;标签实现某个组件缓存功能？"></a>60.vue中如何利用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>标签实现某个组件缓存功能？</h4><p>vue-cli工程中实现某个组件的缓存功能，可用 keep-alive 标签与 vue-router的meta形式数据传递配合完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include&#x3D;&quot;组件名字&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：在 app.vue 里面 template部分 使用 &lt;keep-alive&gt;&lt;/keep-alive&gt; 组件：</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  		&lt;keep-alive&gt;</span><br><span class="line">        	&lt;router-view v-<span class="keyword">if</span>=<span class="string">&quot;$router.meta.keepAlive&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line">        &lt;/keep-alive&gt;</span><br><span class="line">        &lt;router-view v-<span class="keyword">if</span>=<span class="string">&quot;!$router.meta.keepAlive&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：在src/router.js:</span></span><br><span class="line"><span class="keyword">import</span> account <span class="keyword">from</span> <span class="string">&#x27;../page/demo/account.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> course <span class="keyword">from</span> <span class="string">&#x27;../page/demo/course.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">  		&#123; </span><br><span class="line">    		path: <span class="string">&#x27;/account&#x27;</span>, </span><br><span class="line">    		name: <span class="string">&#x27;account&#x27;</span>, </span><br><span class="line">   		 	component: Account, </span><br><span class="line">    		meta:&#123;</span><br><span class="line">            	keepAlive:<span class="literal">false</span> <span class="comment">//false为不缓存</span></span><br><span class="line">            &#125;</span><br><span class="line">  		&#125;，</span><br><span class="line">        &#123; </span><br><span class="line">    		path: <span class="string">&#x27;/course&#x27;</span>, </span><br><span class="line">    		name: <span class="string">&#x27;course&#x27;</span>, </span><br><span class="line">   		 	component: course, </span><br><span class="line">    		meta:&#123;</span><br><span class="line">            	keepAlive:<span class="literal">true</span> <span class="comment">//true为缓存</span></span><br><span class="line">            &#125;</span><br><span class="line">  		&#125; </span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="61-vue中实现切换页面时为左滑出效果"><a href="#61-vue中实现切换页面时为左滑出效果" class="headerlink" title="61.vue中实现切换页面时为左滑出效果"></a>61.vue中实现切换页面时为左滑出效果</h4><p>左滑效果实现，需要使用 <code>&lt;transition&gt;&lt;/transition&gt;</code> 组件配合 css3 动画效果实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">      &lt;!-- 使用transiton来规定页面切换时候的样式--&gt;</span><br><span class="line">      &lt;transition name=<span class="string">&quot;slide-left&quot;</span>&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;/transition&gt; </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">&lt;style lang=<span class="string">&quot;less&quot;</span>&gt;</span><br><span class="line">  <span class="comment">/*左滑动效*/</span></span><br><span class="line">   .slide-left-enter-active &#123;</span><br><span class="line">     animation: slideLeft <span class="number">0.3</span>s;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">/*自定义动画*/</span></span><br><span class="line">  @keyframes slideLeft &#123;</span><br><span class="line">    <span class="keyword">from</span> &#123;</span><br><span class="line">      transform: translate3d(<span class="number">100</span>%, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">/*横坐标,纵坐标,z坐标*/</span></span><br><span class="line">      visibility: visible;</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">      transform: translate3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h4 id="62-在vue-cli工程中如何实现无痕刷新？"><a href="#62-在vue-cli工程中如何实现无痕刷新？" class="headerlink" title="62.在vue-cli工程中如何实现无痕刷新？"></a>62.在vue-cli工程中如何实现无痕刷新？</h4><p>无痕刷新:在不刷新浏览器的情况下,实现页面的刷新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一般常用的两种刷新方法：</span><br><span class="line">window.location.reload()，原生 js 提供的方法；</span><br><span class="line">this.$router.go(0)，vue 路由里面的一种方法；</span><br><span class="line"></span><br><span class="line">这两种方法都可以达到页面刷新的目的，简单粗暴，但是用户体验不好，相当于按 F5 刷新页面，页面的重新载入，会有短暂的白屏。</span><br></pre></td></tr></table></figure>

<p>vue开启无痕刷新</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">原理：先在全局组件注册一个方法，用该方法控制router-view的显示与否，然后在子组件调用全局方法。</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步：在app.vue里面设置</span></span><br><span class="line">    &lt;template&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">             &lt;!--通过切换isRouterAlive的值来控制页面的显示与否--&gt;</span><br><span class="line">             &lt;router-view v-<span class="keyword">if</span>=<span class="string">&quot;isRouterAlive&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span>  <span class="keyword">default</span> &#123;</span><br><span class="line">		<span class="comment">//给子组件暴露一个方法：这里将当前组件中的reload方法暴露给子组件</span></span><br><span class="line">        <span class="function"><span class="title">provide</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>&#123;</span><br><span class="line">                reload:<span class="built_in">this</span>.reload</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                isRouterAlive:<span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            <span class="comment">//reload方法中先把isRouterAlive该为false，让router-view不显示</span></span><br><span class="line">            <span class="comment">//然后在$nextTick方法里面重新把isRouterAlive该为true，让router-view重新显示</span></span><br><span class="line">            <span class="comment">//$nextTick表示下一次dom更新完毕之后，在更新dom的时候我们让router-view隐藏，更新dom完毕我们让router-view显示，此时就做到了无痕刷新</span></span><br><span class="line">            <span class="function"><span class="title">reload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.isRouterAlive = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.isRouterAlive = <span class="literal">true</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：在.vue组件中使用全局方法(先用inject注册全局方法，然后即可通过this调用)</span></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span>  <span class="keyword">default</span>&#123;</span><br><span class="line">        inject:[<span class="string">&#x27;reload&#x27;</span>],</span><br><span class="line">        <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.reload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="63-vue中中央事件总线？"><a href="#63-vue中中央事件总线？" class="headerlink" title="63.vue中中央事件总线？"></a>63.vue中中央事件总线？</h4><p><strong>中央事件总线</strong> ：就是一个名字可以叫做<strong>Bus的vue空实例</strong>,里边没有任何内容。</p>
<p>它就像一个公交车一样，来回输送人，将组件A输送到组件B，再将组件B输送到组件A；</p>
<p>这里A，B组件可以是父、子组件，也可以是兄、弟组件，或者两个没有任何关系的组件；</p>
<p>我们可以使用中央事件总线这种技术来实现vue组件之间的数据通信。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建中央事件总线</span></span><br><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//A组件发送</span></span><br><span class="line"><span class="comment">//2.使用Bus中央事件总线在A组件中发送信息</span></span><br><span class="line">Bus.$emit(<span class="string">&#x27;自定义事件名&#x27;</span>，<span class="string">&#x27;$on发送过来的数据&#x27;</span>)；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//B组件接收</span></span><br><span class="line"><span class="comment">//3.使用Bus中央事件总线在B组件中接收信息</span></span><br><span class="line">Bus.$on(<span class="string">&#x27;自定义事件名&#x27;</span>，<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//然后执行什么你自己懂的。。。</span></span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure>

<h4 id="64-vue开发命令-npm-run-dev-输入后的执行过程【-拓展-】"><a href="#64-vue开发命令-npm-run-dev-输入后的执行过程【-拓展-】" class="headerlink" title="64.vue开发命令 npm run dev 输入后的执行过程【 拓展 】"></a>64.vue开发命令 <code>npm run dev</code> 输入后的执行过程【 拓展 】</h4><ol>
<li>npm run dev 是执行配置在package.json中的脚本，比如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --inline --progress --config webpack.conf.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;npm run dev&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;eslint --ext .js,.vue src&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;node build/build.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">npm run dev 执行的就是webpack-dev-server --inline ....命令,通过webpack-dev-server开启一个本地调试服务器。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在webpack.conf.js文件中找到App的入口文件  ./src/main.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">   app: &#39;.&#x2F;src&#x2F;main.js&#39;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.js用到了页面元素#app、用到了路由和根组件App，并根据这些信息创建一个vue实例</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">     el: &#39;#app&#39;,</span><br><span class="line">     router,</span><br><span class="line">     components: &#123; App &#125;,</span><br><span class="line">     template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>webpack-dev-server会将main.js中的代码以及所有引用打包成一个bundle.js，然后配置到内存中</li>
<li>webpack.conf.js中配置的HtmlWebpackPlugin会将index.html文件配置到内存，并且将内存中的bundle.js注入到内存中的index.html中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: &#39;index.html&#39;,</span><br><span class="line">      template: &#39;index.html&#39;,</span><br><span class="line">      inject: true</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>根据webpack.config.js中所配置的devServer的信息，会决定是否自动打开浏览器呈现网页</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123; </span><br><span class="line">    open: true, &#x2F;&#x2F; 自动打开浏览器</span><br><span class="line">    port: 3000, &#x2F;&#x2F; 设置启动时候的运行端口</span><br><span class="line">    contentBase: &#39;src&#39;, &#x2F;&#x2F; 指定托管的根目录</span><br><span class="line">    hot: true &#x2F;&#x2F; 启用热更新 的 第1步</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="65-vue打包命令是什么？"><a href="#65-vue打包命令是什么？" class="headerlink" title="65.vue打包命令是什么？"></a>65.vue打包命令是什么？</h4><p>vue-cli 生成 生产环境部署资源 的 npm命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build </span><br></pre></td></tr></table></figure>

<p>用于查看 vue-cli 生产环境部署资源文件大小的 npm命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build --report</span><br></pre></td></tr></table></figure>

<h4 id="66-vue-cli-打包后会生成哪些文件？"><a href="#66-vue-cli-打包后会生成哪些文件？" class="headerlink" title="66.vue-cli 打包后会生成哪些文件？"></a>66.vue-cli 打包后会生成哪些文件？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dist</span><br><span class="line">  --index.html       单页面文件</span><br><span class="line">  --app.[hash].css   将组件中的css编译合并成一个app.[hash].css的文件</span><br><span class="line">  --app.[hash].js    包含了所有components中的js代码</span><br><span class="line">  --vendor.[hash].js   包含了生产环境所有引用的node_modules中的代码</span><br><span class="line">  --mainfest.[hash].js 包含了webpack运行环境及模块化所需的js代码</span><br><span class="line">  --0.[hash].js        是vue-router使用了按需加载生产的js文件</span><br><span class="line">  </span><br><span class="line">这样拆分的好处是：每块组件修改重新编译后不影响其他未修改的js文件的hash值，这样能够最大限度地使用缓存，减少HTTP的请求数。</span><br></pre></td></tr></table></figure>

<h4 id="67-如何配置-vue-打包生成文件的路径？"><a href="#67-如何配置-vue-打包生成文件的路径？" class="headerlink" title="67.如何配置 vue 打包生成文件的路径？"></a>67.如何配置 vue 打包生成文件的路径？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vue.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//部署应用包时的URL，如果是生产环境，部署到 ./cli-study/dist 路径；如果是开发环境，部署到根路径</span></span><br><span class="line">publicPath: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>? <span class="string">&#x27;./cli-study/dist&#x27;</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">outputDir: <span class="string">&#x27;dist&#x27;</span>,</span><br></pre></td></tr></table></figure>

<h4 id="68-vue如何优化首屏加载速度？"><a href="#68-vue如何优化首屏加载速度？" class="headerlink" title="68.vue如何优化首屏加载速度？"></a>68.vue如何优化首屏加载速度？</h4><blockquote>
<p>问题描述：</p>
<p>在Vue项目中，引入到工程中的所有js、css文件，编译时都会被打包进vendor.js，浏览器在加载该文件之后才能开始显示首屏。若是引入的库众多，那么vendor.js文件体积将会相当的大，影响首屏的体验。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">几种常用的优化方法：</span><br><span class="line"></span><br><span class="line">1. 路由的按需加载</span><br><span class="line">2. 将打包生成后 index.html页面 里面的JS文件引入方式放在 body 的最后</span><br><span class="line">3. 用cdn缓存代替npm安装包，将引用的外部js、css文件剥离开来，不编译到vendor.js中</span><br><span class="line">4. UI组件库的按需加载</span><br><span class="line">5. 项目部署上线之后，开启服务器的Gzip压缩，使服务器尽可能返回更小的资源</span><br><span class="line">6. 使用更高级的SSR服务端渲染框架，比如nuxt来做首屏加载优化</span><br></pre></td></tr></table></figure>

<h4 id="69-什么是mvvm"><a href="#69-什么是mvvm" class="headerlink" title="69.什么是mvvm"></a>69.什么是mvvm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MVVM最早由微软提出来，它借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离，把Model和View关联起来的就是ViewModel。</span><br><span class="line"></span><br><span class="line">ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model</span><br><span class="line"></span><br><span class="line">View 和 Model 之间的同步工作完全是自动的，无需人为干涉（由viewModel完成）</span><br><span class="line"></span><br><span class="line">因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理</span><br></pre></td></tr></table></figure>

<h4 id="70-MVVM模式的优点以及与MVC模式的区别"><a href="#70-MVVM模式的优点以及与MVC模式的区别" class="headerlink" title="70.MVVM模式的优点以及与MVC模式的区别"></a>70.MVVM模式的优点以及与MVC模式的区别</h4><p><strong>MVVM模式的优点：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、低耦合：MVVM模式中，数据是独立于UI的，ViewModel只负责处理和提供数据，UI想怎么处理数据都由UI自己决定，ViewModel不涉及任何和UI相关的事，即使控件改变（input换成p）,ViewModel几乎不需要更改任何代码，专注自己的数据处理就可以了</span><br><span class="line"></span><br><span class="line">2.自动同步数据:ViewModel通过双向数据绑定把View层和Model层连接了起来，View和Model这两者可以自动同步。程序员不需要手动操作DOM, 不需要关注数据状态的同步问题，MVVM 统一管理了复杂的数据状态维护</span><br><span class="line"></span><br><span class="line">3、可重用性：你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</span><br><span class="line"></span><br><span class="line">4、独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</span><br><span class="line"></span><br><span class="line">5、可测试：ViewModel里面是数据和业务逻辑，View中关注的是UI，这样的做测试是很方便的，完全没有彼此的依赖，不管是UI的单元测试还是业务逻辑的单元测试，都是低耦合的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>MVVM 和 MVC 的区别：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvc 和 mvvm 其实区别并不大。都是一种设计思想，主要区别如下：</span><br><span class="line">1.mvc 中 Controller演变成 mvvm 中的 viewModel</span><br><span class="line">2.mvvm 通过数据来驱动视图层的显示而不是节点操作。</span><br><span class="line">3.mvc中Model和View是可以直接打交道的，造成Model层和View层之间的耦合度高。而mvvm中Model和View不直接交互，而是通过中间桥梁ViewModel来同步</span><br><span class="line">4.mvvm主要解决了:mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</span><br></pre></td></tr></table></figure>

<h4 id="71-常见的实现数据劫持的做法有哪些"><a href="#71-常见的实现数据劫持的做法有哪些" class="headerlink" title="71.常见的实现数据劫持的做法有哪些"></a>71.常见的实现数据劫持的做法有哪些</h4><p>实现数据劫持的做法有大致如下几种：</p>
<blockquote>
<p>1.代理对象（proxy）<br>2.Object.defineProperty()</p>
</blockquote>
<hr>
<p>1、代理对象</p>
<p>通过代理对象来访问目标对象，可以实现数据的劫持。</p>
<p>在代理的设计模式中，有目标对象、代理对象和事件处理程序，通过代理对象来访问目标对象，可以实现对目标对象的访问权限控制以及数据的劫持工作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个事件处理器</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;A value has been accessed&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj[prop];</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop, value</span>)</span>&#123;</span><br><span class="line">        obj[prop] = value;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prop&#125;</span>is being set to<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标对象</span></span><br><span class="line"><span class="keyword">const</span> initialObj = &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">&#x27;Foo Bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理对象</span></span><br><span class="line"><span class="keyword">const</span> proxiedObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(initialObj, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给代理对象赋值，会调用handler这个事件处理程序，然后调用事件处理程序中的set方法间接访问目标对象，给目标对象赋值</span></span><br><span class="line">proxiedObj.age = <span class="number">24</span></span><br></pre></td></tr></table></figure>

<hr>
<p>2、<code>Object.defineProperty()</code>:</p>
<hr>
<p>vue.js 则是采用<code>Object.defineProperty()</code>来实现数据的劫持的，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时立马能侦听到从而调用setter和getter做对应的处理。</p>
<h4 id="72-Object-defineProperty-方法的作用是什么？"><a href="#72-Object-defineProperty-方法的作用是什么？" class="headerlink" title="72.Object.defineProperty()方法的作用是什么？"></a>72.Object.defineProperty()方法的作用是什么？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数说明：</span></span><br><span class="line">obj：必需。目标对象 </span><br><span class="line">prop：必需。需定义或修改的属性的名字</span><br><span class="line">descriptor：必需。目标属性所拥有的特性</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line">传入函数的对象。即第一个参数obj</span><br></pre></td></tr></table></figure>

<h4 id="73-Vue项目中常用到的加载器："><a href="#73-Vue项目中常用到的加载器：" class="headerlink" title="73.Vue项目中常用到的加载器："></a>73.Vue项目中常用到的加载器：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- vue-loader -- 用于加载与编译 *.vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理。</span><br><span class="line">- vue-style-loader -- 用于加载 *.vue 文件中的样式</span><br><span class="line">- style-loader -- 用于将样式直接插入到页面的&lt;style&gt;内</span><br><span class="line">- css-loader -- 用于加载 *.css 样式表文件;</span><br><span class="line">- less-loader -- 用于编译与加载 *.less 文件（需要依赖less库）</span><br><span class="line">- babel-loader -- 用于将 ES6 编译成为浏览器兼容的ES5</span><br><span class="line">- file-loader -- 用于直接加载文件</span><br><span class="line">- url-loader -- 用于加载 URL 指定的文件，多用于字体与图片的加载</span><br><span class="line">- json-loader -- 用于加载 *.json 文件作为 JS 实例。</span><br></pre></td></tr></table></figure>

<h4 id="74-跨域问题的解决方案"><a href="#74-跨域问题的解决方案" class="headerlink" title="74.跨域问题的解决方案"></a>74.跨域问题的解决方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在前端开发中，当我们使用ajax向服务器发送请求的时候，当协议、域名、和端口号有任何一个不一致的时候就会产生跨域问题。</span><br><span class="line"></span><br><span class="line">跨域问题有很多中解决方案：我所用过的有：</span><br><span class="line"></span><br><span class="line">1.jsonp 他的本质是使用script标签去发送请求，然后服务器返回一段js脚本以供客户端执行</span><br><span class="line"></span><br><span class="line">2.cors 他需要在服务器端配置跨域访问的响应头</span><br><span class="line"></span><br><span class="line">3.在前端的工程化项目(webpack)中,我们可以通过配置devserver的proxy来解决跨域访问的问题。他的原理是在本地开启一个服务器向数据服务器发送请求，因为服务器和服务器之间是没有跨域</span><br><span class="line"></span><br><span class="line">4.但是因为webpack的devserver只在开发环境下有效，当项目发布上线之后仍然会有跨域问题，为了解决项目上线的跨域问题，我们配置服务器的反向代理（ngix）</span><br><span class="line"></span><br><span class="line">5.除此之外，我还知道当项目打包成apk之后就不存在跨域问题了，所以如果项目要打包成apk，我们需要在项目中的所有请求中写全路径(此时我们可以配置axios.default.baseURL来解决)</span><br></pre></td></tr></table></figure>

<h4 id="75-Vue的双向数据绑定的原理"><a href="#75-Vue的双向数据绑定的原理" class="headerlink" title="75.Vue的双向数据绑定的原理"></a>75.Vue的双向数据绑定的原理</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.由页面-&gt;数据的变化：通过给页面元素添加对应的事件监听来实现的</span></span><br><span class="line">&lt;input v-model=<span class="string">&quot;value&quot;</span> oninput=<span class="string">&quot;()=&gt;this.handleInput($event)&quot;</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleInput</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = e.target.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.由数据-&gt;页面的变化：通过数据劫持（Object.defineProperty） + 发布订阅模式来实现的</span></span><br><span class="line">具体流程：</span><br><span class="line">A.Compile解析器会将页面上的插值表达式/指定翻译成对应Watcher以添加到订阅器维护的列表中</span><br><span class="line">B.通过<span class="built_in">Object</span>.defineProperty劫持数据的变化，一旦数据源发生变化会触发对应的set方法</span><br><span class="line">C.在set方法中，通知订阅器(Dep)对象中维护的所有订阅者(Watcher)列表更新</span><br><span class="line">D.每一个Watch会去更新对应的页面</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.关于发布订阅模式</span></span><br><span class="line">发布订阅模式又叫观察者模式，他定义了一种一对多的关系，让多个观察者对象同时监听某一个主体对象的变化，当这个主题对象的状态发生变化的时候就会通知所有的观察者对象，是的他们能够自动更新自己。</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/11/vue%E9%9D%A2%E8%AF%95%E9%A2%98/1576572541458.png" alt="1576572541458"></p>
<h4 id="76-函数的节流阀和去抖"><a href="#76-函数的节流阀和去抖" class="headerlink" title="76.函数的节流阀和去抖"></a>76.函数的节流阀和去抖</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.函数去抖</span></span><br><span class="line">	答：函数调用n秒后才会执行，如果函数在n秒内被调用的话则函数不执行，重新计算执行时间。函数去抖主要避免快速多次执行函数（操作DOM，加载资源等等）给内存带来大量的消耗从而一定程度上降低性能问题。</span><br><span class="line">    </span><br><span class="line">    函数去抖的应用场景：</span><br><span class="line">    <span class="number">1.</span>监控键盘keypress事件，每当内容变化的时候就向服务器发送请求</span><br><span class="line">    <span class="number">2.</span>在页面滚动的时候监控页面的滚动事件，会频繁执行scroll事件</span><br><span class="line">    <span class="number">3.</span>监控页面的resize事件，拉动窗口改变大小的时候，resize事件被频繁的执行</span><br><span class="line">    </span><br><span class="line">    上面三种场景中都会频繁触发指定事件，比如第一种情况，每当输入框内容变化之后就向服务器发送请求，可能会导致一秒钟向服务器请求很多次，这显然是不合理的，我们可以使用函数去抖来优化。</span><br><span class="line"></span><br><span class="line">       &lt;input type=<span class="string">&quot;text&quot;</span> oninput=<span class="string">&quot;textInput()&quot;</span>&gt;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//模拟发送请求的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;发送请求&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//文本框输入内容的时候频繁的处罚func方法</span></span><br><span class="line">        <span class="keyword">var</span> func = debounce(ajax,<span class="number">1000</span>)</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">textInput</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            func();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//函数去抖方法的封装</span></span><br><span class="line">        <span class="comment">//debounce: 当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">method, delay</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> context = <span class="built_in">this</span></span><br><span class="line">                <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">                timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    method.apply(context, args);</span><br><span class="line">                &#125;, delay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.函数节流（throttle）：函数预先设定一个执行周期(或者节流阀)，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method,duration</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span>  begin = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> context = <span class="built_in">this</span></span><br><span class="line">            <span class="keyword">var</span> args=<span class="built_in">arguments</span></span><br><span class="line">            <span class="keyword">var</span> current=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">current-begin&gt;=duration</span>)</span>&#123;</span><br><span class="line">                 method.apply(context,args);</span><br><span class="line">                 begin = current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizehandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onresize=throttle(resizehandler,<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">函数节流的应用场景：</span><br><span class="line"><span class="number">1.</span>上拉下拉刷新，每拉动一次彻底完毕之后才可以下一次拉动</span><br><span class="line"><span class="number">2.</span>图片轮播动画，每一张图片动画完成之后才开始下一个图片的动画</span><br></pre></td></tr></table></figure>

<h4 id="77-vue中引入组件、注册组件、使用组件的步骤"><a href="#77-vue中引入组件、注册组件、使用组件的步骤" class="headerlink" title="77.vue中引入组件、注册组件、使用组件的步骤"></a>77.vue中引入组件、注册组件、使用组件的步骤</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>引入组件</span><br><span class="line">  <span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;@/components/App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>注册组件</span><br><span class="line">  注册全局组件 :  Vue.component(<span class="string">&quot;组价名字&quot;</span>,&#123;<span class="attr">template</span>:<span class="string">&quot;&lt;div&gt;页面模板&lt;/div&gt;&quot;</span>&#125;)</span><br><span class="line">  注册私有组件 :  在当前组件/vue对象 使用components属性来声明私有组件</span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span>使用组件 </span><br><span class="line">  当我们通过 <span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;@/components/App.vue&#x27;</span> 这种方式引入组件之后，我们就可以在页面中使用组件了。</span><br><span class="line">  &lt;App&gt;&lt;/App&gt;</span><br><span class="line">  使用组件的时候，我们还可以通过属性给子组件传递数据,比如&lt;App msg=<span class="string">&quot;123&quot;</span>&gt;&lt;/App&gt;</span><br><span class="line">  在子组件中可以通过props来接收数据。</span><br><span class="line">  同样子组件也可以给父组件传递数据,....</span><br></pre></td></tr></table></figure>

<h4 id="78-单页和多页应用的优缺点"><a href="#78-单页和多页应用的优缺点" class="headerlink" title="78.单页和多页应用的优缺点"></a>78.<strong>单页和多页应用的优缺点</strong></h4><p>1.什么是单页面？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">单页面应用(SPA),通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的html,js,css.</span><br><span class="line">优点：用户体验好</span><br><span class="line">　　    前后端分离</span><br><span class="line">　　　  页面效果会比较炫酷（比如切换页面内容时的专场动画）</span><br><span class="line">缺点：不利于seo</span><br><span class="line">　　　　导航不可用，如果一定要导航需要自行实现前进，后退。</span><br><span class="line">　　　　初次加载时耗时多</span><br><span class="line">　　　　页面负责度提高很多</span><br></pre></td></tr></table></figure>

<p>2.什么是多页面？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">多页面(MPA),就是只一个应用中有多个页面，页面跳转时是整页刷新</span><br><span class="line">优点：有利于seo</span><br><span class="line">　　　开发成本较低</span><br><span class="line">缺点：网站的后期维护难度较大</span><br><span class="line">　　　页面之间的跳转用时较长，用户体验较差。</span><br><span class="line">　　　代码重复度大</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">崔文悦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wy-cui.github.io/2020/11/11/vue%E9%9D%A2%E8%AF%95%E9%A2%98/">https://wy-cui.github.io/2020/11/11/vue%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Wy-Cui.github.io" target="_blank">崔文悦的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/11/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">我的第一篇博客文章</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">崔文悦</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">1.vue组件传值几种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-vue-router%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">2.vue-router原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9E%84%E5%BB%BA%E7%9A%84-vue-cli-%E5%B7%A5%E7%A8%8B%E9%83%BD%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3.构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-vue-cli-%E5%B7%A5%E7%A8%8B%E5%B8%B8%E7%94%A8%E7%9A%84-npm-%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4.vue-cli 工程常用的 npm 命令有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AF%B7%E8%AF%B4%E5%87%BAvue-cli%E5%B7%A5%E7%A8%8B%E4%B8%AD%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%A8%E5%A4%84"><span class="toc-number">5.</span> <span class="toc-text">5.请说出vue-cli工程中每个文件夹和文件的用处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-vue-config-js-%E7%9A%84%E5%AF%B9%E4%BA%8E%E5%B7%A5%E7%A8%8B-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%92%8C-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83-%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">6.</span> <span class="toc-text">6.vue.config.js 的对于工程 开发环境 和 生产环境 的配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%AF%B7%E4%BD%A0%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%BA%9B-package-json-%E9%87%8C%E9%9D%A2%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">7.</span> <span class="toc-text">7.请你详细介绍一些 package.json 里面的配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-vue-js%E7%9A%84%E6%A0%B8%E5%BF%83"><span class="toc-number">8.</span> <span class="toc-text">8.vue.js的核心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%AF%B9%E4%BA%8E-Vue-%E6%98%AF%E4%B8%80%E5%A5%97-%E6%9E%84%E5%BB%BA%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2-%E7%9A%84-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%A1%86%E6%9E%B6-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">9.</span> <span class="toc-text">9.对于 Vue 是一套 构建用户界面 的 渐进式框架 的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E8%AF%B7%E8%AF%B4%E5%87%BAvue%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">10.</span> <span class="toc-text">10.请说出vue几种常用的指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E8%AF%B7%E9%97%AE-v-if-%E5%92%8C-v-show-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">11.请问 v-if 和 v-show 有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-vue%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">12.</span> <span class="toc-text">12.vue常用的修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-v-on%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">13.v-on可以监听多个方法吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-vue%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">14.</span> <span class="toc-text">14.vue中 key 值的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-vue%E4%BA%8B%E4%BB%B6%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8event%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.</span> <span class="toc-text">15.vue事件中如何使用event对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E4%BB%80%E4%B9%88%E6%98%AF-nextTick"><span class="toc-number">16.</span> <span class="toc-text">16.什么是$nextTick</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-Vue-%E7%BB%84%E4%BB%B6%E4%B8%AD-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-number">17.</span> <span class="toc-text">17.Vue 组件中 data 为什么必须是函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-v-for-%E4%B8%8E-v-if-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">18.</span> <span class="toc-text">18.v-for 与 v-if 的优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-vue%E4%B8%AD%E5%AD%90%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">19.</span> <span class="toc-text">19.vue中子组件调用父组件的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-vue%E4%B8%AD-keep-alive-%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">20.</span> <span class="toc-text">20.vue中 keep-alive 组件的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-vue%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">21.</span> <span class="toc-text">21.vue中如何编写可复用的组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E4%BB%80%E4%B9%88%E6%98%AFvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">22.什么是vue生命周期和生命周期钩子函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">23.</span> <span class="toc-text">23.vue生命周期钩子函数有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%8C%89%E9%94%AE"><span class="toc-number">24.</span> <span class="toc-text">24.vue如何监听键盘事件中的按键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-vue%E6%9B%B4%E6%96%B0%E6%95%B0%E7%BB%84%E6%97%B6%E8%A7%A6%E5%8F%91%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">25.</span> <span class="toc-text">25.vue更新数组时触发视图更新的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-vue%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%9B%B4%E6%94%B9%E6%A3%80%E6%B5%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">26.</span> <span class="toc-text">26.vue中对象更改检测的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%9D%9E%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%EF%BC%8C%E7%BD%91%E9%80%9F%E6%85%A2%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5%E9%9D%A2%E9%97%AA%E5%8A%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">27.如何解决非工程化项目，网速慢时初始化页面闪动问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-v-for%E4%BA%A7%E7%94%9F%E7%9A%84%E5%88%97%E8%A1%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0active%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">28.v-for产生的列表，如何实现active样式的切换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-vue-cli%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">29.vue-cli工作中如何自定义一个过滤器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-vue-cli%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">30.</span> <span class="toc-text">30.vue-cli工作中常用的过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-vue%E7%AD%89%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">31.</span> <span class="toc-text">31.vue等单页面应用及其优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E4%BB%80%E4%B9%88%E6%98%AFvue%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">32.什么是vue的计算属性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-vue-cli%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%A0%E7%A7%8D%E8%84%9A%E6%89%8B%E6%9E%B6%E6%A8%A1%E6%9D%BF"><span class="toc-number">33.</span> <span class="toc-text">33.vue-cli提供的几种脚手架模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-vue%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">34.</span> <span class="toc-text">34.vue父组件如何向子组件中传递数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F"><span class="toc-number">35.</span> <span class="toc-text">34.如何在组件中使用全局常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35-vue%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E5%BC%B9%E7%AA%97%E5%90%8E%E9%9D%A2%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%BB%9A%E5%8A%A8"><span class="toc-number">36.</span> <span class="toc-text">35.vue如何禁止弹窗后面的滚动条滚动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36-%E8%AF%B7%E8%AF%B4%E5%87%BA%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-computed-%E7%9A%84%E7%BC%93%E5%AD%98%E5%92%8C%E6%96%B9%E6%B3%95-method-%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">36.请说出计算属性(computed)的缓存和方法(method)调用的有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37-%E4%BB%80%E4%B9%88%E6%98%AFvue-js%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">38.</span> <span class="toc-text">37.什么是vue.js中的自定义指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E5%87%A0%E4%B8%AA%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">39.</span> <span class="toc-text">38.自定义指令的几个钩子函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">40.</span> <span class="toc-text">39.自定义指令钩子函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-vue-router%E5%A6%82%E4%BD%95%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">41.</span> <span class="toc-text">40.vue-router如何响应路由参数的变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-%E5%AE%8C%E6%95%B4%E7%9A%84-vue-router-%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-number">42.</span> <span class="toc-text">41.完整的 vue-router 导航解析流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-vue-router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%EF%BC%88-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB-%EF%BC%89%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">42.vue-router有哪几种导航钩子（ 导航守卫 ）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43-vue-router%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">44.</span> <span class="toc-text">43.vue-router的几种实例方法以及参数传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44-route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">45.</span> <span class="toc-text">44.$route 和 $router 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#45-vue-router%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-number">46.</span> <span class="toc-text">45.vue-router的动态路由匹配以及使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#46-vue-router%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1"><span class="toc-number">47.</span> <span class="toc-text">46.vue-router如何定义嵌套路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-lt-router-link-gt-lt-router-link-gt-%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E5%B1%9E%E6%80%A7"><span class="toc-number">48.</span> <span class="toc-text">47.&lt;router-link&gt;&lt;&#x2F;router-link&gt;组件及其属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#48-vue-router%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%EF%BC%88-%E6%87%92%E5%8A%A0%E8%BD%BD-%EF%BC%89"><span class="toc-number">49.</span> <span class="toc-text">48.vue-router实现动态加载路由组件（ 懒加载 ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#49-%E4%BB%80%E4%B9%88%E6%98%AFvuex%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">49.什么是vuex？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#50-%E4%BD%BF%E7%94%A8vuex%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">51.</span> <span class="toc-text">50.使用vuex的核心概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#51-%E5%A6%82%E4%BD%95%E5%9C%A8vuex%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E4%BF%AE%E6%94%B9%EF%BC%9F"><span class="toc-number">52.</span> <span class="toc-text">51.如何在vuex中使用异步修改？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52-Promise%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">53.</span> <span class="toc-text">52.Promise对象是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53-axios%E3%80%81fetch%E4%B8%8Eajax%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">54.</span> <span class="toc-text">53.axios、fetch与ajax有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#54-axios%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">55.</span> <span class="toc-text">54.axios有什么特点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#55-vue%E7%BB%84%E4%BB%B6%E7%9A%84scoped%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">56.</span> <span class="toc-text">55.vue组件的scoped属性的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#56-vue%E4%B8%AD%E9%9B%86%E6%88%90%E7%9A%84UI%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-number">57.</span> <span class="toc-text">56.vue中集成的UI组件库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#57-%E5%A6%82%E4%BD%95%E9%80%82%E9%85%8D%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%9F%E3%80%90-%E7%BB%8F%E5%85%B8-%E3%80%91"><span class="toc-number">58.</span> <span class="toc-text">57.如何适配移动端？【 经典 】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#58-vue-cli%E5%B7%A5%E7%A8%8B%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%83%8C%E6%99%AF%E5%9B%BE%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">58.vue-cli工程中如何使用背景图？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#59-vue%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0tab%E5%88%87%E6%8D%A2%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">60.</span> <span class="toc-text">59.vue中如何实现tab切换功能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#60-vue%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-lt-keep-alive-gt-lt-keep-alive-gt-%E6%A0%87%E7%AD%BE%E5%AE%9E%E7%8E%B0%E6%9F%90%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">61.</span> <span class="toc-text">60.vue中如何利用&lt;keep-alive&gt;&lt;&#x2F;keep-alive&gt;标签实现某个组件缓存功能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#61-vue%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%88%87%E6%8D%A2%E9%A1%B5%E9%9D%A2%E6%97%B6%E4%B8%BA%E5%B7%A6%E6%BB%91%E5%87%BA%E6%95%88%E6%9E%9C"><span class="toc-number">62.</span> <span class="toc-text">61.vue中实现切换页面时为左滑出效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#62-%E5%9C%A8vue-cli%E5%B7%A5%E7%A8%8B%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E7%97%95%E5%88%B7%E6%96%B0%EF%BC%9F"><span class="toc-number">63.</span> <span class="toc-text">62.在vue-cli工程中如何实现无痕刷新？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#63-vue%E4%B8%AD%E4%B8%AD%E5%A4%AE%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%EF%BC%9F"><span class="toc-number">64.</span> <span class="toc-text">63.vue中中央事件总线？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#64-vue%E5%BC%80%E5%8F%91%E5%91%BD%E4%BB%A4-npm-run-dev-%E8%BE%93%E5%85%A5%E5%90%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E3%80%90-%E6%8B%93%E5%B1%95-%E3%80%91"><span class="toc-number">65.</span> <span class="toc-text">64.vue开发命令 npm run dev 输入后的执行过程【 拓展 】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#65-vue%E6%89%93%E5%8C%85%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">66.</span> <span class="toc-text">65.vue打包命令是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#66-vue-cli-%E6%89%93%E5%8C%85%E5%90%8E%E4%BC%9A%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-number">67.</span> <span class="toc-text">66.vue-cli 打包后会生成哪些文件？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#67-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-vue-%E6%89%93%E5%8C%85%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="toc-number">68.</span> <span class="toc-text">67.如何配置 vue 打包生成文件的路径？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#68-vue%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="toc-number">69.</span> <span class="toc-text">68.vue如何优化首屏加载速度？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#69-%E4%BB%80%E4%B9%88%E6%98%AFmvvm"><span class="toc-number">70.</span> <span class="toc-text">69.什么是mvvm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#70-MVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E4%BB%A5%E5%8F%8A%E4%B8%8EMVC%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">71.</span> <span class="toc-text">70.MVVM模式的优点以及与MVC模式的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#71-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E7%9A%84%E5%81%9A%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">72.</span> <span class="toc-text">71.常见的实现数据劫持的做法有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#72-Object-defineProperty-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">73.</span> <span class="toc-text">72.Object.defineProperty()方法的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#73-Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9A"><span class="toc-number">74.</span> <span class="toc-text">73.Vue项目中常用到的加载器：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#74-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">75.</span> <span class="toc-text">74.跨域问题的解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#75-Vue%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">76.</span> <span class="toc-text">75.Vue的双向数据绑定的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#76-%E5%87%BD%E6%95%B0%E7%9A%84%E8%8A%82%E6%B5%81%E9%98%80%E5%92%8C%E5%8E%BB%E6%8A%96"><span class="toc-number">77.</span> <span class="toc-text">76.函数的节流阀和去抖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#77-vue%E4%B8%AD%E5%BC%95%E5%85%A5%E7%BB%84%E4%BB%B6%E3%80%81%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6%E3%80%81%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">78.</span> <span class="toc-text">77.vue中引入组件、注册组件、使用组件的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#78-%E5%8D%95%E9%A1%B5%E5%92%8C%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">79.</span> <span class="toc-text">78.单页和多页应用的优缺点</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/11/11/vue%E9%9D%A2%E8%AF%95%E9%A2%98/" title="vue面试题"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue面试题"/></a><div class="content"><a class="title" href="/2020/11/11/vue%E9%9D%A2%E8%AF%95%E9%A2%98/" title="vue面试题">vue面试题</a><time datetime="2020-11-11T12:19:08.000Z" title="发表于 2020-11-11 20:19:08">2020-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" title="我的第一篇博客文章"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我的第一篇博客文章"/></a><div class="content"><a class="title" href="/2020/11/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" title="我的第一篇博客文章">我的第一篇博客文章</a><time datetime="2020-11-09T12:14:06.000Z" title="发表于 2020-11-09 20:14:06">2020-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/09/hello-world/" title="Hello World"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2020/11/09/hello-world/" title="Hello World">Hello World</a><time datetime="2020-11-09T10:49:53.845Z" title="发表于 2020-11-09 18:49:53">2020-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/02/11/222/" title="222"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="222"/></a><div class="content"><a class="title" href="/2020/02/11/222/" title="222">222</a><time datetime="2020-02-11T11:41:12.000Z" title="发表于 2020-02-11 19:41:12">2020-02-11</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By 崔文悦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>